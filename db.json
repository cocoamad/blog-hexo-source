{"Asset":{"kre89tlvvjjz34kz":{"source":"source/CNAME","mtime":1393488428000,"modified":true,"_id":"kre89tlvvjjz34kz","full_source":"/Users/yuan.sun/git/blog-hexo-source/source/CNAME","path":"CNAME"},"kj1ba8vemz32uv0g":{"source":"source/favicon.ico","mtime":1394433902000,"modified":true,"_id":"kj1ba8vemz32uv0g","full_source":"/Users/yuan.sun/git/blog-hexo-source/source/favicon.ico","path":"favicon.ico"},"f9agi5gukeoi9a4t":{"source":"themes/present/source/js/script.js","mtime":1394434346000,"modified":true,"_id":"f9agi5gukeoi9a4t","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/js/script.js","path":"js/script.js"},"rxozj2ydo67lwzvj":{"source":"themes/present/source/css/style.styl","mtime":1394176893000,"modified":true,"_id":"rxozj2ydo67lwzvj","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/style.styl","path":"css/style.styl"},"ayjrkc3tcq4f6cko":{"source":"themes/present/source/css/fonts/FontAwesome.otf","mtime":1394176893000,"modified":true,"_id":"ayjrkc3tcq4f6cko","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf"},"hmwqkqbk3y70j18r":{"source":"themes/present/source/css/fonts/fontawesome-webfont.eot","mtime":1394176893000,"modified":true,"_id":"hmwqkqbk3y70j18r","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot"},"v56o8n857ivyqqe3":{"source":"themes/present/source/css/fonts/fontawesome-webfont.svg","mtime":1394176893000,"modified":true,"_id":"v56o8n857ivyqqe3","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg"},"ioezwb5foc5fjyym":{"source":"themes/present/source/css/fonts/fontawesome-webfont.ttf","mtime":1394176893000,"modified":true,"_id":"ioezwb5foc5fjyym","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf"},"h7hip1fkxtmxpp7t":{"source":"themes/present/source/css/fonts/fontawesome-webfont.woff","mtime":1394176893000,"modified":true,"_id":"h7hip1fkxtmxpp7t","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff"},"c0ikopkbvegwpurb":{"source":"themes/present/source/css/images/banner.png","mtime":1394176314000,"modified":true,"_id":"c0ikopkbvegwpurb","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/images/banner.png","path":"css/images/banner.png"},"yz379qv7g55xchl3":{"source":"themes/present/source/fancybox/blank.gif","mtime":1394176893000,"modified":true,"_id":"yz379qv7g55xchl3","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/blank.gif","path":"fancybox/blank.gif"},"tyirqz0yz4kb21on":{"source":"themes/present/source/fancybox/fancybox_loading.gif","mtime":1394176893000,"modified":true,"_id":"tyirqz0yz4kb21on","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif"},"hie6qepxxd3h0ovr":{"source":"themes/present/source/fancybox/fancybox_loading@2x.gif","mtime":1394176893000,"modified":true,"_id":"hie6qepxxd3h0ovr","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif"},"kk9moe9edl0281po":{"source":"themes/present/source/fancybox/fancybox_overlay.png","mtime":1394176893000,"modified":true,"_id":"kk9moe9edl0281po","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png"},"qbeofu2sqnmwbjvz":{"source":"themes/present/source/fancybox/fancybox_sprite.png","mtime":1394176893000,"modified":true,"_id":"qbeofu2sqnmwbjvz","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png"},"de1838s5gi79xab4":{"source":"themes/present/source/fancybox/fancybox_sprite@2x.png","mtime":1394176893000,"modified":true,"_id":"de1838s5gi79xab4","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png"},"teamgllu8f6agbsi":{"source":"themes/present/source/fancybox/jquery.fancybox.css","mtime":1394176893000,"modified":true,"_id":"teamgllu8f6agbsi","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css"},"ew24d3zdcptdrrgz":{"source":"themes/present/source/fancybox/jquery.fancybox.pack.js","mtime":1394176893000,"modified":true,"_id":"ew24d3zdcptdrrgz","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js"},"22gpawrmq8go8fju":{"source":"themes/present/source/fancybox/jquery.fancybox.js","mtime":1394176893000,"modified":true,"_id":"22gpawrmq8go8fju","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js"},"ugf2m1t1vbwizh4u":{"source":"themes/present/source/fancybox/helpers/fancybox_buttons.png","mtime":1394176893000,"modified":true,"_id":"ugf2m1t1vbwizh4u","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png"},"jxnb8z6tuvx9mctq":{"source":"themes/present/source/fancybox/helpers/jquery.fancybox-buttons.css","mtime":1394176893000,"modified":true,"_id":"jxnb8z6tuvx9mctq","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css"},"a1xs042h3jevdbnc":{"source":"themes/present/source/fancybox/helpers/jquery.fancybox-buttons.js","mtime":1394176893000,"modified":true,"_id":"a1xs042h3jevdbnc","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js"},"ct4boyv28djk997p":{"source":"themes/present/source/fancybox/helpers/jquery.fancybox-thumbs.css","mtime":1394176893000,"modified":true,"_id":"ct4boyv28djk997p","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css"},"3sqn0j2re7ktke78":{"source":"themes/present/source/fancybox/helpers/jquery.fancybox-media.js","mtime":1394176893000,"modified":true,"_id":"3sqn0j2re7ktke78","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js"},"1mapwq95hbtwefgx":{"source":"themes/present/source/fancybox/helpers/jquery.fancybox-thumbs.js","mtime":1394176893000,"modified":true,"_id":"1mapwq95hbtwefgx","full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js"}},"Cache":{"c9ridz41zi9gtan8":{"content":"title: ios程序员6级考试\ndate: 2014-03-06 23:10:58\ntags: ios6级考试\n---\n## 前言\n\nios面试题看过来\n题目多来源于项目中遇到的错误和平时的误区，要是都能了如指掌，恭喜你，6级过了- -。  \n考点大概是对ios框架、objc语言基础的理解，以看代码为主（那种“谈谈xxxx的理解的题就算了吧”）  \n\n不断总结中...\n\n > It's examing time...  \n\n------\n\n##1. 下面的代码分别输出什么？  \n\n\n```\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self)\n    {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n<!--more-->\n\n##2. 下面的代码报错？警告？还是正常输出什么？\n```\nFather *father = [Father new];\nBOOL b1 = [father responseToSelector:@selector(responseToSelector:)];\nBOOL b2 = [Father responseToSelector:@selector(responseToSelector:)];\nNSLog(@\"%d, %d\", b1, b2);\n```\n\n##3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\n\n```\n...\n// 当前在主线程\n\n[request startAsync]; // 后台线程异步调用，完成后会在主线程调用completionBlock\nsleep(100); // sleep主线程，使得下面的代码在后台线程完成后才能执行\n[request setCompletionBlock:^{\n    NSLog(@\"Can I be printed?\");\n}];\n...\n```\n\n##4. 不使用IB时，下面这样做有问题么？\n```\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n  CGRect frame = CGRectMake(0, 0, self.view.bounds.size.width * 0.5, self.bounds.size.height * 0.5);\n  UIView *view = [[UIView alloc] initWithFrame:frame];\n  [self.view addSubview:view];\n}\n```\n\n\n-----\n# 答案和解答\n[请戳我，我是传送门](http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/)\n-----\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","mtime":1398146528000,"source":"_posts/ios_exam_0.md","_id":"c9ridz41zi9gtan8"},"39kiepegh7xz109h":{"content":"title: hexo的私人订制\ndate: 2014-03-07 16:26:34\ntags: hexo\n---\n\n#准备工作\n##Fork it!\n从0开始多费劲，先从hexo的主题中选一个看的过去的，从上面加工。\n这次选的是hexo的默认主题`Landscape`，觉得一个大banner挺好看而已。\n主题在github上，https://github.com/hexojs/hexo-theme-landscape  \n废话不说，先fork一份，虽然不会再merge回去了。\nfork完去setting页面改个名字，就叫它`present`了，因为当时看到群里正说`presentViewController`的事- -\n\n<!--more-->\n\n![][1]\n * hexo工程的`themes/`目录默认是在`.gitignore`里的，意思是主题和内容是应该分开的\ntheme作为主项目的`submodule`，所以主题更改时也应该单独提交了\n\n##Clone it！\n把刚fork的名为`present`的theme安装到hexo目录：\n``` sh\n$ git clone https://github.com/sunnyxx/present themes/present\n```\n去`/_config.yml`中找到并设置：\n```\n# Extensions\n## Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n## Themes: https://github.com/tommy351/hexo/wiki/Themes\ntheme: present // 修改这儿\n```\n运行下`hexo server`就能立刻看到效果了\n\n#开始定制theme\n先得看看hexo theme里面的结构：\n\n - _config.yml - 主题总体配置\n - /layout/*.ejs - 网页布局\n - /source/css/*.styl - 网页样式\n\n##定制banner\n![banner][2]\n默认的banner图是个地球星空图，先从它下手，这张图位于`/themes/present/source/css/images/banner.jpg`\n这图分辨率有`1920x1200`之大，显示的部分很少，搞一张喜欢的banner图，PS成大概的尺寸（高度还就得设的很大才行，虽然只显示一小部分，否则会出现显示不出来图片的状况），我这儿PS过的是一张png，名为`banner.png`，文件名修改需找找到位于`/themes/present/source/css/_variables.styl`中，修改为`banner.png`  \n**当然，考虑到github的访问速度，这张大图我最后决定用上传微博图床，使用生成的URL，这样加载就快很多**\n```\n// Header\nlogo-size = 40px\nsubtitle-size = 16px\nbanner-height = 404px // 看看多高合适\nbanner-url = \"images/banner.png\" // 修改这里\n```\n然后就变成这鸟样了：\n![专业多了][3]\n这个标题横在这儿太恶心了，我的banner里面已经有标题了，这就是需要修改布局了，header的布局在`/themes/present/layout/_partial/header.ejs`，打开修改：\n```\n// 把这一段都注释掉好了：\n<div id=\"header-title\" class=\"inner\">\n    <h1 id=\"logo-wrap\">\n        <a href=\"<%- config.root %>\" id=\"logo\"><%= config.title %></a>\n    </h1>\n    <% if (theme.subtitle){ %>\n        <h2 id=\"subtitle-wrap\">\n          <a href=\"<%- config.root %>\" id=\"subtitle\"><%= theme.subtitle %></a>\n        </h2>\n    <% } %>\n</div>\n```\n然后世界变清净了。\n![丑][4]\n默认主题里面banner上下都有个渐变，换了图之后就尤其丑，干掉之。\n这个是样式的修改，所以肯定在`present/source/css/_partial`里面了，再看这位置明显是header嘛，所以`header.styl`就是你了：\n```\n#header\n  height: banner-height\n  position: relative\n  border-bottom: 1px solid color-border\n  &:before, &:after\n    content: \"\"\n    position: absolute\n    left: 0\n    right: 0\n    height: 40px\n  &:before\n    top: 0\n    background: linear-gradient(rgba(0, 0, 0, 0.2), transparent) // 找到你了，注释掉！\n  &:after\n    bottom: 0\n    background: linear-gradient(transparent, rgba(0, 0, 0, 0.2)) // 也找到你了，注释掉！\n```\n瞬间清爽很多，但又发现去掉之后字看不清了：\n![看不清！][5]\n还是在这个文件：\n\n```\n$nav-link\n  float: left\n  color: #000 // 改个深色\n  opacity: 1.0 // 别半透明的\n  text-decoration: none\n  /*text-shadow: 0 1px rgba(0, 0, 0, 0.2)*/ // 改个阴影\n  transition: opacity 0.2s\n  display: block\n  padding: 20px 15px\n  &:hover\n    opacity: 1\n```\nmuch better\n![better][6]\n\n##定制样式\n\n列几个常用的：\n\n在`/themes/present/source/css/_variables.styl`中：\n\n####调整主区域布局（很值得修改）\n默认的主题的主区域太窄了，没几个字就得换行，下面的`main-column`控制主区域宽，`sidebar-column`控制sidebar宽，这两个值加一起凑成全部宽度，会居中对齐。\n```\n// Layout\nblock-margin = 20px\narticle-padding = 20px // 文章内缩进\nmobile-nav-width = 280px\nmain-column = 12 // 主文章区域的宽度\nsidebar-column = 3 // 侧边栏区域的宽度\n```\n####修改代码字体\n\n```\nfont-mono = Menlo/*Menlo必须提前面啊*/, \"Source Code Pro\", Monaco, Consolas, Consolas, monospace\n```\n####修改正文字体和行高\n```\nfont-size = 15px // Menlo字体我看15px的很清楚\nline-height = 1.6em\nline-height-title = 1.3em\n```\n\n\n-----\n位于`/themes/present/source/css/_partial/article.styl`的样式文件负责文章里面的样式\n####修改图片格式\n```\n  img, video\n    max-width: 80%\n    height: auto\n    display: block\n    margin: auto\n```\n去除图片的描述的caption的话，去`present/source/js/script.js`中修改：\n```\n// Caption\n  $('.article-entry').each(function(i){\n    $(this).find('img').each(function(){\n      if ($(this).parent().hasClass('fancybox')) return;\n\n      var alt = this.alt;\n\n      // if (alt) $(this).after('<span class=\"caption\">' + alt + '</span>'); 这个去掉\n\n      $(this).wrap('<a href=\"' + this.src + '\" title=\"' + alt + '\" class=\"fancybox\"></a>');\n    });\n\n    $(this).find('.fancybox').each(function(){\n      $(this).attr('rel', 'article' + i);\n    });\n  });\n```\n\n####修改blockquote样式\n```\n  blockquote\n    font-family: font-serif\n    font-size: 2.0em // 搞大点\n    margin: line-height 20px\n    text-align: left // 必须应该左对齐啊\n```\n\n-----\n位于`/themes/present/source/css/_extend.styl`的样式文件定义了基本样式\n####修改标题样式\n```\n  h1\n    font-size: 2em\n  h2\n    font-size: 1.5em\n  h3\n    font-size: 1.3em\n  h4\n    font-size: 1.2em\n  h5\n    font-size: 1em\n  h6\n    font-size: 1em\n    color: color-grey\n```\n\n####修改文章背景\n```\n$block\n  background: #fbfbfb // 白里透着灰\n  /*box-shadow: 1px 2px 3px #eee*/ // 扁平化咋能要阴影\n  border: 1.5px solid #ccc // 边框\n  border-radius: 10px // 圆角矩形走起\n```\n\n##定制代码样式\n这个必须单拿出来写  \n> We shall show no mercy to those shit colored codes ----- sunnyxx\n\n代码的高亮样式在`present/source/css/_partial/highlight.styl`中\n```\n$code-block\n  background: highlight-background\n  /*margin: 0 article-padding * -1*/\n  margin: auto // 默认的顶边对齐是怎么回事？改个居中\n  padding: 15px article-padding\n  border-style: solid\n  border-color: color-border\n  border-width: 0px 0\n  border-radius: 5px // 加个圆角~\n  overflow: auto\n  color: highlight-foreground\n  line-height: font-size * line-height\n\n$line-numbers\n  color: #666\n  font-size: 0.85em // 行号大小\n\n...\n\n.highlight\n    @extend $code-block\n    pre\n      border: none\n      margin: 0\n      padding: 0\n    table\n      margin: 0\n      width: auto\n      font-size: 14px // 设置代码字体\n      letter-spacing: 1px // 设置字间距，要不太挤了\n\n```\nCode block高亮：`我是小代码块高亮`\n```\n.article-entry\n  pre, code\n    font-family: font-mono\n  code\n    background: #e3e3e3\n    color: #666\n    border-radius: 3px // 也来个圆角\n    border-width 1px\n    border-color: #fff\n    text-shadow: 0 1px #fff\n    padding: 0.1em 0.3em // 控制大小\n```\n\n#开始定制widget\n\n##添加多说评论\n在`present/layout/_partial/article.ejs`中最下面，要不用discuss的话先注掉，换成下面的：\n\n```\n<% if (!index && post.comments){ %>\n<section id=\"comments\">\n  <!-- Duoshuo Comment BEGIN -->\n  <div class=\"ds-thread\"></div>\n    <script type=\"text/javascript\">\n      var duoshuoQuery = {short_name:\"sunnyxx\"};\n        (function() {\n          var ds = document.createElement('script');\n          ds.type = 'text/javascript';ds.async = true;\n          ds.src = 'http://static.duoshuo.com/embed.js';\n          ds.charset = 'UTF-8';\n          (document.getElementsByTagName('head')[0]\n          || document.getElementsByTagName('body')[0]).appendChild(ds);\n        })();\n  </script>\n<!-- Duoshuo Comment END -->\n</section>\n<% } %>\n```\n##添加友情链接\n首先，在`present/layout/_widget/`目录下新建一个文件，随便copy个当前目录下的改名也行，我这儿叫`friends.ejs`\n编辑这个文件：\n```\n<div class=\"widget tag\">\n\t<h3 class=\"title\">友情链接</h3>\n\t<ul class=\"entry\">\n\t<li><a href=\"http://zhouxl.github.io\" title=\"小六\">小六的博客</a></li>\n\t</ul>\n</div>\n```\n里面以上面的格式定义友情链接，css套用了tag定义好的格式，随后修改`present/_config.yml`\n```\n# Sidebar\nsidebar: right\nwidgets:\n- category\n- tag\n- tagcloud\n- archive\n- recent_posts\n- friends // 新加的就是刚才`_widget`目录中新建的文件的文件名\n```\n然后刷新页面，效果就出来了~\n\n  [1]: http://ww3.sinaimg.cn/large/51530583gw1ee7835uauoj20j804mwen.jpg\n  [2]: http://ww4.sinaimg.cn/large/51530583gw1ee78mkdkspj20jp06bq3h.jpg\n  [3]: http://ww2.sinaimg.cn/large/51530583gw1ee790pxkk9j20fv085t9c.jpg\n  [4]: http://ww3.sinaimg.cn/large/51530583gw1ee79b2xop4j201u0bt0sm.jpg\n  [5]: http://ww4.sinaimg.cn/large/51530583gw1ee79ex02pgj206901u0qo.jpg\n  [6]: http://ww3.sinaimg.cn/large/51530583tw1ee79mmlwkaj205401iwe9.jpg\n","mtime":1395386344000,"source":"_posts/hexo_customize.md","_id":"39kiepegh7xz109h"},"vadp7tdjgkcica02":{"content":"title: hexo边搭边记\ndate: 2014-02-27 14:56:47\ntags: hexo\n---\n\n#Install\n**安装nvm（Node Version Manager）**，Terminal中运行\n\n    $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n会提示：\n\n    => Close and reopen your terminal to start using NVM\n退出Terminal重启后nvm命令才能生效。  使用nvm安装node.js：\n<!--more-->\n    $ nvm install 0.10\n下完后安装hexo，这一步时间比较长：\n\n    $ npm install -g hexo\n\n然后找个文件初始化blog：\n\n    $ cd ~/git/blog  \n    $ hexo init .\n    $ ls\n生成出的目录结构：\n\n    .\n    ├── _config.yml\n    ├── package.json\n    ├── scaffolds\n    ├── scripts\n    ├── source\n    |   ├── _drafts\n    |   └── _posts\n    └── themes\n\n新建一篇文章：\n\n    $ hexo new mac下使用hexo搭建blog\n$ open source/_posts/mac下使用hexo搭建blog.md\n编辑md后生成html：\n\n    $ hexo generate\n本地预览：\n\n    $ hexo server\n    => [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.\nTheme，去官方提供的[主题列表][1]中选个现成的，按照里面的方法pull下来，如light主题\n\n\n    $ git clone git://github.com/tommy351/hexo-theme-light.git themes/light\n\n_config.yml配置文件中设置：\n\n    theme: light\n重新generate和server预览，就看到变化了。\n\n##deploy\n\ngithub上建个respository，设置里设一下\n在`_config.yml`中：\n``` yml\ndeploy:\ntype: github\nrepository: https://github.com/sunnyxx/blog-hexo.git\n```\n然后执行：\n\n    $ hexo deploy\n就行了，github会多一个branch，比octopress简单\n\n##绑定域名\n去万网买了这个域名`sunnyxx.com`，以`blog.sunnyxx.com`作为博客的域名，\n看万网是阿里的才从那儿买的，后来发现`DNSPod`貌似比较好，万网的后台做的那叫一个*，但愿解析速度上别再不行就行。\n托管在github上，首先建一个CNAME文件，里面写`最终指向`的域名：\n``` bash\n$ blog.sunnyxx.com > public/CNAME\n```\n然后去域名后台配置下，由于github表示说我托管的页面的域名是：`sunnyxx.github.io`\n所以建一个CNAME记录，将`blog.sunnyxx.com`解析到`sunnyxx.github.io`\nDNS域名解析最常用的是**A记录**和**CNAME记录**，A记录把域名解析到服务器IP，CNAME相当于把一个域名指向另一个域名，因此我这个用的是CNAME，要是托管的服务器也是自己搭的那就用A记录了。\n完事之后得等一段时间（DNSPod说几秒内就同步完，要是这样真心是它好）\n使用下面的命令测一下域名的解析\n``` bash\n$ dig blog.sunnyxx.com +nostats +nocomments +nocmd\n\n=> output:\n;; global options: +cmd\n;blog.sunnyxx.com.      IN  A\nblog.sunnyxx.com.   1778    IN  CNAME   sunnyxx.github.io.\nsunnyxx.github.io.  1778    IN  CNAME   github.map.fastly.net.\ngithub.map.fastly.net.  30  IN  A   103.245.222.133\n```\n这说明是成功了，发现解析过程是`blog.sunnyxx.com`->`sunnyxx.github.io`->`github.map.fastly.net`->`103.245.222.133` 最终指向了github的web server\n由于国内GreatWall，解析速度明显不稳定，有时候都连不上，以后再看怎么办吧\n\n##添加sitemap\n同样的，我们使用hexo提供的插件，方法与添加RSS类似。\n安装sitemap到本地：\n```\nnpm install hexo-generator-sitemap\n```\n开启sitemap功能：编辑hexo/_config.yml，添加如下代码：\n```\nplugins:\n- hexo-generator-sitemap\n```\n访问zipperary/sitemap.xml即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。\n\n\n\n##文章中插入图片\n\n原来用octopress写的时候在目录下面建个`images`目录来保存图片，引用时使用了相对路径就行了，但这是让我最蛋疼的事，想发个图片还得命个名，然后`mv`过去，再引进来，特别墨迹。hexo中当然也可以用这种方法，但是发现使用个`图床`来搞定图片真是一劳永逸了。\n\n\n**微博图床**，地址http://weibotuchuang.sinaapp.com/，我是chrome用户，所以下了个他的插件，装完了点开发现直接把图片拖进去就行了：\n![enter image description here][3]\n生成的地址直接用就行了\n有时候需要使用QQ截屏，只要随便截到某个人的聊天窗口里面，不用发送，然后直接拖拽到这个小窗口里面就OK了。\n> Life saver.\n\nPS：gif也没问题\n![1231231][2]\n##StackEdit - 超赞的Markdown在线编辑器  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"500px\" />\n\n界面干净，所见即所得，支持同步到`Dropbox`和`github`，这个特别好，比如在公司写了点东西就可以一键同步，保留犯罪现场，回来之后继续写剩下的。\n\n遇到的问题\n-----\n第二次用的时候发现安装的hexo命令找不到了，重新use一下：\n```\n$ nvm use 0.10\n```\n\n**使用StackEdit时改变图片大小**\n\n```\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px align=\"center\" />\n```\n效果：\n  <img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px\" />\n\n##添加友情链接\n\n`themes/xxxxxx/layout/_widget/blogroll.ejs`\n```\n<div class=\"widget tag\">\n<h3 class=\"title\">友情链接</h3>\n<ul class=\"entry\">\n<li><a href=\"http://zhouxl.github.io\" title=\"小六\">小六的博客</a></li>\n</ul>\n</div>\n```\n\n  [1]: https://github.com/tommy351/hexo/wiki/Themes\n  [2]: http://ww2.sinaimg.cn/large/51530583gw1ee17y3p11zg207804lnhh.gif\n  [3]: http://ww2.sinaimg.cn/large/51530583gw1ee18d6ak6yj208c08ydg6.jpg\n  [4]: https://stackedit.io/res-min/img/logo-promo-128.png\n","mtime":1395386344000,"source":"_posts/hexo_startup.md","_id":"vadp7tdjgkcica02"},"n93glddshi7ehnu1":{"content":"title: objc arc的秘密\ndate: 2014-03-15 19:02:59\ntags: objc的秘密\n---\n##ARC or not？\n`Automatic Reference Counting`是objc发展以来相当重要的一个进步  \n> 对于开发者，任何能降低开发难度，简化代码的功能，我们都应该去了解和使用。\n> 我们应该利用一切“偷懒”的机会，将软件开发的复杂度分解并控制在一个个小的范围内，使得对于分解后的每一个小的任务，都能被新手掌握和维护。  \n\n基于简化开发的思想来看，ARC绝对是一个**没理由拒绝**的技术进步。  \nARC随着iOS5问世，到现在iOS8都快出了，你还在手动写retain，release么？除了固守思想外，对ARC的恐惧大都来自对它的未知。  \n<!-- more -->\n比如我在公司尝试说服team使用ARC时被质疑的几个问题：\n####ARC和Java的GC一样，会导致一部分性能损耗？\n首先，ARC和GC是两码事，ARC是编译时编译器“帮你”插入了原本需要自己手写的内存管理代码，而非像GC一样运行时的垃圾回收系统  \n####ARC内存不知道什么时候释放，导致不可控的内存涨落？\n了解ARC的原理后，就知道，ARC下编译器插入的内存管理的代码是经过优化的，对于使用完的内存，多运行一行代码都不会浪费，可以这么说，手写的内存管理必须达到很严谨的水平才可能达到ARC自动生成的一样完整且没有疏漏\n####ARC下面自己不管理内存，很不爽，很没有安全感\n这纯粹是习惯的问题了，开发者的目标是用最简化的手段完成一个最可靠的程序，进步需要改变的。好在编译选项中提供了`-fobjc-arc`和`-fno-objc-arc`来保证整个的变革的继续下去，就像社会主义中国里的港澳\n\n##ARC的约定\n使用ARC之后一个费解的地方是，一个方法生成的对象，没有任何附加标示，ARC怎么知道生成的对象是不是`autorelease`的呢？\n```\n@interface Sark : NSObject\n+ (instancetype)sarkWithMark:(NSString *)mark; // 1\n- (instancetype)initWithMark:(NSString *)mark; // 2\n@end\n```\n这是非ARC时常用的手段，1生成autorelease对象，2生成普通对象，而现在ARC不能调用autorelease，使用时怎么能知道呢？\n```\n{\n    // ...\n    Sark *sark1 = [Sark sarkWithMark:@\"萨萨萨\"];\n    Sark *sark2 = [[Sark alloc] initWithMark:@\"萨萨萨\"];\n}\n```\n使用`约定`，NS定义了下面三个编译属性  \n```\n#define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))\n#define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))\n#define NS_RETURNS_INNER_POINTER __attribute__((objc_returns_inner_pointer))\n```\n这三个属性是Clang自己使用的标示，除非`特殊情况`不要自己使用，但是这些对理解ARC是很有帮助的。  \n这里还要介绍一个概念，`Method family`\n> An Objective-C method may fall into a method family, which is a conventional set of behaviors ascribed to it by the Cocoa conventions.\n\n指的是命名上表示一类型的方法，比如`- init`和`- initWithMark:`都属于`init`的family  \n于是乎，编译器约定，对于`alloc`,`init`,`copy`,`mutableCopy`,`new`这几个家族的方法，后面默认加`NS_RETURNS_RETAINED`标识；而其他不指名标识的family的方法默认添加`NS_RETURNS_NOT_RETAINED`标识  \n也就是说刚才的方法，在编译器看来是这样的：\n```\n@interface Sark : NSObject\n+ (instancetype)sarkWithMark:(NSString *)mark NS_RETURNS_NOT_RETAINED; // 1\n- (instancetype)initWithMark:(NSString *)mark NS_RETURNS_RETAINED; // 2\n@end\n```\n这也就是为什么ARC下面，不能把一个属性定义成名字是这样的：\n```\n@property (nonatomic, copy) NSString *newString; // 编译器不允许\n```\n`- newString`就成了`new`家族的方法，内存就不对了\n对于`NS_RETURNS_INNER_POINTER`这货，主要使用在返回的是一个对象的**内部C指针**的情况，如NSString的方法：\n```\n- (__strong const char *)UTF8String NS_RETURNS_INNER_POINTER;\n```\n就使用了这个标识，这个就不深入研究了，直接上文档：\n> An Objective-C method returning a non-retainable pointer may be annotated with the objc_returns_inner_pointer attribute to indicate that it returns a handle to the internal data of an object, and that this reference will be invalidated if the object is destroyed. When such a message is sent to an object, the object’s lifetime will be extended until at least the earliest of:\nthe last use of the returned pointer, or any pointer derived from it, in the calling function or\nthe autorelease pool is restored to a previous state.\n\n##ARC的内存管理函数\n上面说，ARC区别于GC，是在我们的代码中插入内存管理的代码，那么这些代码究竟是什么？  \n使用Xcode查看汇编代码的方法，先调出：\n![](http://ww3.sinaimg.cn/large/51530583gw1eehmxl9gx9j205o01m0sm.jpg)\n然后在上边的栏中选择：\n![](http://ww1.sinaimg.cn/large/51530583gw1eehmwfezi3j205v0ccwf0.jpg)\n这样，源代码的汇编结果就能显示出来。\n\n// TODO:","mtime":1395386344000,"source":"_posts/objc_arc_secret.md","_id":"n93glddshi7ehnu1"},"w2jdb46n795467z1":{"content":"title: objc@interface的设计哲学与设计技巧\ndate: 2014-04-13 13:01:54\ntags: objc刨根问底\n---\n\n# 我是前言\n学习objc时，尤其是先学过其他编程语言再来看objc时，总会对objc的**类**声明的关键字`interface`感到有点奇怪，在其它面向对象的语言中通常由`class`关键字来表示，而`interface`在java中表示的却大约相当于objc的`protocol`，这个关键字的区别究竟代表了objc语言的设计者怎样的思想呢，在objc类设计中需要注意哪些问题呢？接下来对这个问题进行一些思考和探究.   \n\n-----\n\n# interface?\n先来段Wiki:  \n> In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with each other. These are definitions of methods and values which the objects agree upon in order to cooperate.\n\n接口约定了对象间交互的属性和方法，使得对象间无需了解对方就可以协作。  \n说的洋气点就是`解耦`嘛，细心点也能发现Wiki中`interface`和`protocol`表示了相近的语义。    \n引用我和项目组架构师讨论有关interface的问题时他的说法:\n\n> interface就是一个object定义的可以被外界影响的方式\n\n<!--more-->  \n\n说着他指了下旁边桌子上放着的一把伞，说，这把伞我可以打开它，打开这个动作就是它的一个interface，桌子旁边还放着一个盒子，虽然它和伞都放在这张桌子上，但是它们之间永远不会互相影响，所以：  \n\n> interface只存在于能互相影响的两者间  \n\n-----\n\n# @interface生成了class？\n\n学习objc时最早接触的就是怎么写一个类了，从`.h`中写`@interface`声明类，再从`.m`中写`@implementation`实现方法，所以，objc中写一个`@interface`就相当于c++中写一个`class`。但这是真的么？  \n\n写个小test验证一下： \n有两个类，`Sark`和`Dark`，`Sark`类只有`.m`文件，其中只写`@implementation`；`Dark`类只有`.h`头文件，其中只写`@interface`，然后如下测试代码：  \n\n\n```\nClass sarkClass = NSClassFromString(@\"Sark\");\nClass darkClass = NSClassFromString(@\"Dark\");\n```\n\n`NSClassFromString`方法调用了runtime方法，根据类名将加载进runtime的这个类找出来，没有这个类就回返回空(Nil)。   \n结果是`sarkClass`存在，而`darkClass`为空，说明什么？是否说明其实`@implementation`才是真正的Class？  \n进一步，不止能取到这个没有@interface的类，还可以正常调用方法（因为万能的runtime）  \n\n如下面的测试代码： \n```\nSark *sark = [Sark new];\n[sark speak];\n```\n\n要是没有`@interface`的声明，类名，方法名都会报错说找不到，但是可以像下面一样绕一下：  \n\n```\nClass cls = NSClassFromString(@\"Sark\");\nid obj = [cls performSelector:NSSelectorFromString(@\"new\")];\n[obj performSelector:NSSelectorFromString(@\"speak\")];\n```\n\n其实，从`rewrite`后的objc代码可以发现，对于消息的发送，恰恰就是会被处理成类似上面的代码，使用字符串mapping出`Class`，`selctor`等再使用`objc_msgSend()`进行函数调用，如下面所示： \n\n```\n// 经过clang -rewrite-objc 命令重写后的代码\nSark *sark = ((id (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"Sark\"), sel_registerName(\"new\"));\n((void (*)(id, SEL))(void *)objc_msgSend)((id)sark, sel_registerName(\"speak\"));\n```\n\n\n# 对比@interface和@implementation\n\n`@interface` 我们干过的事：\n1. 继承\n2. 声明协议\n3. 定义实例变量（@interface后面加大括号那种）\n4. 定义@property\n5. 声明方法 \n\n`@implementation` 我们干过的和可以干的事：  \n1. 继承\n2. 定义实例变量\n3. 合成属性（@synthesize和@dynamic）\n3. 实现方法（包括协议方法）\n\n在`@implementation`干一些事情用的相对较少，但是是完全合法的，如这样用：  \n\n``` \n@implementation Sark : NSObject {\n    NSString *_name;\n}\n```\n\n通过对比可以发现，**@interface对objc类结构的合成并无决定性作用**，加上**无决定性**是因为如果没有`@interface`会丢失一些类自省的原始数据，如属性列表和协议列表，但对于纯粹的对象消息发送并无影响。  \n所以说，可以得出这么一个结论，**objc中@interface就是为了给调用者看的，是和调用者的一个protocol**，没错，就是**protocol**。\n\n# 对比@interface和@protocol\n\n与其把`@implementation`扯进来不如对比下`@protocol`  \n\n\n我理解objc的`@interface`和`@protocal`间唯一的区别就是**是否和一个类型绑定**，这让我想起来`鸭子类型`(Duck typing), [wiki链接](http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B) \n\n> “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”\n\nDuck type在objc的体现无疑就是`@protocol`了，我们常用`id<XXXDelegate> delegate`的方式声明一个delegate，我们无需care这货到底是什么类型，我们只知道他能干什么就可以work了。同样的功能我也可以使用`XXXDelegate *delegate`的方式来定义，只不过这样的话这个类又需要耦合一个`XXXDelegate`类型，而这个delegate类是它原本并不需要关心的。  \n\n所以说，**`@interface`是`@protocol`的强类型升级版。**  \n\n举个`NSObject`的栗子最合适：  \n```\n@interface NSObject <NSObject> {\n    Class isa;\n}\n```\nNSObject之所以成为NSObject，绝大多数都是`<NSObject>`协议定义的方法，实体类@interface定义的唯一一个变量`isa`指针，为了继承链和消息传递。    \n除了`<NSObject>`协议外，NSObject还有很多Category来补充它的功能，其实仔细想想，Category更像protocol，一个`补充协议`，同样不能添加实例变量，但是和`@interface`一样需要与Class绑定。  \n\n进一步来讲，自从属性能自动合成变量之后，在头文件`@interface`中写大括号声明实例变量的情况越来越少（可以参见近几个版本iOS SDK中类头文件里这种写法几乎消失），因此，`@interface`和`@protocol`的差别进一步缩小。  \n\n-----\n\n# 类与接口的设计原则 - 电视和遥控器\n\n我喜欢将`Class`和`interface`的关系比喻成`电视+遥控器`，那么objc中的消息机制就可以理解成：  \n**用户（caller）通过遥控器（interface）上的按钮（methods）发送红外线（message）来操纵电视（object）**  \n所以，有没有遥控器，电视都在那儿，也就是说，有没有interface，class都是存在的，只是这种存在并没有意义，就好像这个电视没人会打开，没人会用，没人能看，一堆废铁摆在那儿。  \n\n![](http://ww4.sinaimg.cn/large/51530583tw1efdy7cw48wj20c108qjru.jpg)\n\n对比简洁的遥控器，一个拥有很多按钮的老式电视遥控器，我们经常会用到的按钮能有几个呢？\n![](http://ww4.sinaimg.cn/large/51530583tw1efe08u9hb7j208c0b4jrp.jpg)\n\n所以，在设计一个类的interface的时候，如同在设计遥控器应该有怎样功能的按钮，要从调用者的角度出发，区分边界，应该时刻有以下几点考虑： \n1. 这个方法或属性真的属于这个类的职责么？（电视遥控器能遥控空调？）\n2. 这个方法或属性真的必须放在`.h`中（而不是放在`.m`的类扩展中）么？\n3. 调用者必须看文档才能知道这个类该如何使用么？（同一个业务需要调用者按顺序调用多次（而不是将这些细节隐藏，同时提供一个简洁的接口）才行）\n4. 调用者是否可以很容易发现类内部的变量和实现方式？（脑补下电视里面一块电路板漏在外面半截- -） \n5. ...  \n\n\n-----\n\n# objc的@interface设计技巧Tips  \n\n看过不少代码，从@interface设计上多少就能看出作者的水平，分享下我对于这个问题的一些拙见。 \n\n## 只暴露外部需要看到的\n\n比如，有如下一个类（这个类无意义，主要关注写法）：  \n```\n// Sark.h\n@interface SarkViewController : NSObject <NSXMLParserDelegate /*1*/, NSCopying> {\n    NSString *_name; // 2\n    IBOutlet UITextField *_nameTextField; // 2\n}\n@property (nonatomic, strong) NSXMLParser *parser; // 3\n- (IBAction)nameChangedAction:(id)sender; // 4\n@end\n```\n\n这个interface出现的问题：\n1. 类内部自己使用的协议，如`<NSXMLParserDelegate>`不应该在头文件@interface中声明，而应该在类扩展中声明；公开由外部调用的协议，如`<NSCopying>`则写在这儿是正确的。  \n2. `实例变量`和`IBOutlet`不应出现在这儿定义，这将类的内部实现暴露了出去，自从属性可以自动合成后，这里就更应该清净了。\n3. 内部使用的属性对象不要暴露在外，应该移动到类扩展中。\n4. 调用者对IBAction同样不需要关心，那么就不应该放在这儿。  \n\n## 合理分组子功能\n\n- 将相同功能的一组属性或方法写在一起  \n\n使用这个类或者对其进行修改时，一般都是从功能上找，所以把同一功能模块的一组属性或方法写在一块\n\n- 纯操作方法的子功能（无需向类添加变量）使用`Category`分块  \n- 在头文件中也可以使用`类扩展`将interface按功能分区 \n\n`Category`里不能添加实例变量，但是类扩展可以，一般都在`.m`中作为私有interface使用，同样在头文件里作为分区使用，如，ReactiveCocoa中的[RACStream.h](https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACStream.h)  \n\n## 避免头文件污染  \n首先，类实现内部.m文件中使用的其他interface应该在.m文件import，如果也写在header中就会造成对调用者的污染；当interface中出现其他`Class`或`protocol`时，可以使用前置声明`@class XXX`, `@protocol XXX`；当模块（一组类）内部间需要有一些定义（如常量、类型）而又不需要模块使用者知道时，使用一个内部头文件在模块中使用。\n\n## 避免接口过度设计\n考虑调用者的使用方便是很必要的，过火了反而增加了复杂度：  \n\n```\n@interface Sark : NSObject\n- (instancetype)init;\n- (instancetype)initWithName:(NSString *)name;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex age:(NSInteger)age;\n- (instancetype)initWithName:(NSString *)name sex:(NSString *)sex age:(NSInteger)age friends:(NSArray *)friends;\n// 无数多个 //\n@end\n```\n\n提供了一组这样的方法，调用者可能只能用到其中的一个，那这样倒不如只留一个接口。  \n\n## 避免单例的滥用  \n\n单例模式固然好用，但感觉有点过度，将接口设计成单例入口前需要考虑一下：  \n1. 这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？\n2. 这个单例持有的内存一直存在\n3. 是否能用类方法代替？  \n4. 这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为属性  \n\n\n## 隐藏继承关系中的私有接口\n\n感谢`@像条狗在飞`在留言中提出的问题，问题大概可以总结为：当子类需要使用父类的一个私有属性（方法）时，需要把这个属性（方法）放到父类的header中，但暴露给子类的同时暴露给了外部调用者，如何解决?   \n\n我的方案是：建立一个`私有header`，使用`类扩展`定义父类需要暴露给子类的属性（方法），然后在各自的`.m`文件中引用，如：  \n\n有Father类和Son类，继承关系，可以考虑建一个如`FatherPrivate.h`的私有header：\n\n```\n// FatherPrivate.h\n@interface Father ()\n@property (nonatomic, copy) NSString *privateThingSonNeed;\n- (void)privateMethodNeedsSonOverride;\n@end\n```\n\n同时在Father.m和Son.m中同时import这个私有header，这样，Father和Son内部对于定义的属性和方法都是透明的，而对外部是隐藏的（因为两个类的header中都没有import这个私有header）  \n\n\n-----\n\n# 总结  \n\n- `@implementation`合成了Class，而非`@interface`，`@interface`是`@protocol`的强类型升级版，它们和`Category`都表示了相近的含义\n- 我们应该善于面向接口编程，划清边界，将类的实现隐藏在调用者所见之外，使主调和被调者之间保持`最少知识原则`\n- `@interface`本身就是最好的文档  \n\n-----  \n\n# References\nhttp://en.m.wikipedia.org/wiki/Interface_(object-oriented_programming)  \nhttp://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B   \n\n-----\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n","mtime":1398327434000,"source":"_posts/objc_dig_interface.md","_id":"w2jdb46n795467z1"},"1eodkmwkzhzusl9q":{"content":"title: NSLog效率低下的原因及尝试lldb断点打印Log\ndate: 2014-04-22 19:47:41\ntags: objc刨根问底\n---\n\n# 我是前言\n打Log是我们debug时最简单朴素的方法，`NSLog`对于objc开发就像`printf`对于c一样重要。但在使用`NSLog`打印大量Log，尤其是在游戏开发时（如每一帧都打印数据），`NSLog`会明显的拖慢程序的运行速度（游戏帧速严重下滑）。本文探究了一下`NSLog`如此之慢的原因，并尝试使用lldb断点调试器替代NSLog进行debug log。\n\n<!--more-->   \n\n-----\n\n# 小测试\n\n测试下分别使用`NSLog`和`printf`打印10000次耗费的时间。`CFAbsoluteTimeGetCurrent()`函数可以打印出当前的时间戳，精度还是很高的，于是乎测试代码如下：\n\n```\nCFAbsoluteTime startNSLog = CFAbsoluteTimeGetCurrent();\nfor (int i = 0; i < 10000; i++) {\n    NSLog(@\"%d\", i);\n}\nCFAbsoluteTime endNSLog = CFAbsoluteTimeGetCurrent();\n\nCFAbsoluteTime startPrintf = CFAbsoluteTimeGetCurrent();\nfor (int i = 0; i < 10000; i++) {\n    printf(\"%d\\n\", i);\n}\nCFAbsoluteTime endPrintf = CFAbsoluteTimeGetCurrent();\n\nNSLog(@\"NSLog time: %lf, printf time: %lf\", endNSLog - startNSLog, endPrintf - startPrintf);\n```\n\n这个时间和机器肯定有关系，只看它们的差别就好。为了全面性，尝试了三种平台： \n\n```\nNSLog time: 4.985445, printf time: 0.084193 // mac\nNSLog time: 5.562460, printf time: 0.019408 // 模拟器\nNSLog time: 10.471490, printf time: 0.090503 // 真机调试(iphone5)\n```\n\n可以发现，在mac上（模拟器其实也算是mac吧）速度差别达到了60倍左右，而真机调试甚至达到了离谱的100多倍。  \n\n-----   \n\n# 探究原因\n基本上这种事情一定可以在Apple文档中找到，看`NSLog`的文档，第一句话就说：`Logs an error message to the Apple System Log facility.`，所以首先，`NSLog`就不是设计作为普通的debug log的，而是error log；其次，`NSLog`也并非是`printf`的简单封装，而是`Apple System Log`(后面简称ASL)的封装。   \n## ASL\nASL是个啥？从[官方手册](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html)上，或者从终端执行`man 3 asl`都可以看到说明：   \n\n>These routines provide an interface to the Apple System Log facility.  They are intended to be a\n     replacement for the syslog(3) API, which will continue to be supported for backwards compatibility.   \n   \n\n大概就是个系统级别的log工具吧，syslog的替代版，提供了一系列强大的log功能。不过一般我们接触不到，NSLog就对它提供了高层次的封装，如[这篇文档](https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1)所提到的：  \n\n>You can use two interfaces in OS X to log messages: ASL and Syslog. You can also use a number of higher-level approaches such as NSLog. However, because most daemons are not linked against Foundation or the Application Kit, the low-level APIs are often more appropriate   \n\n一些底层相关的守护进程(deamons)不会link如Foundation等高层框架，所以asl用在这儿正合适；而对于应用层的用NSLog。   \n\n在`CocoaLumberjack`的[文档](https://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance)中也说了NSLog效率低下的问题： \n\n> NSLog does 2 things:  \n> - It writes log messages to the Apple System Logging (asl) facility. This allows log messages to show up in Console.app.   \n> - It also checks to see if the application's stderr stream is going to a terminal (such as when the application is being run via Xcode). If so it writes the log message to stderr (so that it shows up in the Xcode console).\n\n> To send a log message to the ASL facility, you basically open a client connection to the ASL daemon and send the message. BUT - each thread must use a separate client connection. So, to be thread safe, every time NSLog is called it opens a new asl client connection, sends the message, and then closes the connection.   \n\n意识大概是说，NSLog会向ASL写log，同时向Terminal写log，而且同时会出现在`Console.app`中（Mac自带软件，用NSLog打出的log在其中全部可见）；不仅如此，每一次NSLog都会新建一个ASL client并向ASL守护进程发起连接，log之后再关闭连接。所以说，当这个过程出现N次时，消耗大量资源导致程序变慢也就不奇怪了。  \n\n## 时间和进程信息\n主要原因已经找到，还有个值得注意的问题是`NSLog`每次会将当前的系统时间，进程和线程信息等作为前缀也打印出来，如：  \n\n```\n2012-34-56 12:34:56.789 XXXXXXXX[36818:303] xxxxxx\n```\n当然这些也可能是作为ASL的参数创建的，但不论如何，一定是有消耗的（虽然这个prefix十有八九不是我们需要的看到的）   \n\n------ \n\n\n# 如何是好\n\nNSLog有这样的消耗问题，那该怎么办呢？\n\n1. 拒绝残留的Log。现在项目都是多人共同开发，我们应该只把Log作为错误日志或者重要信息的日志使用，commit前请把自己调试的log去掉（尤其是在循环里写log的小伙伴，简直不能一起快乐的玩耍了）\n2. release版本中消除Log。debug归debug，再慢也不能波及到release版本，用预编译宏过滤下就好。\n3. 是时候换个Log系统了，如`CocoaLumberjack`，自建一个简单的当然也挺好（其实为了项目需要自己也写了个小log系统，实现可以按名字和级别显示log和一些扩展功能，以后有机会分享下）\n\n不过个人认为debug时最好还是用调试器进行调试（尤其是只需要知道某个变量值的时候）\n\n-----\n\n\n# 尝试使用断点+lldb调试器打Log\n\n关于强大的`lldb`调试器用一个专题来讲都是应该，现在只了解一些皮毛，不过就算皮毛的功能也可以替代NSLog这种方法进行调试了，重要的一点是:**使用断点log不需要重新编译工程**，况且和Xcode已经结合的很好，在此先只说打Log这件事。   \n\n\n## 简单断点+po(p)\n断点时可以在xcode的lldb调试区使用`po`或`p`命令打印对象或变量，对于当前栈帧中引用到的变量都是可见的，所以说假如只是看一眼某个对象运行到这儿是不是存在，是什么值的话，设个断点就够了，况且IDE已经把这个功能集成，鼠标放变量上就可以了。  \n\nlldb一些常用调试技巧可以这篇[入门教程](http://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/)   \n\n## Condition和Action断点\n断点不止能把程序断住，触发时也按一定条件，而且可以执行（一个或多个）Action，在断点上右键选择`Edit Breakpoint`，弹出的断点设置中可以添加一些Action：    \n![](http://ww2.sinaimg.cn/large/51530583tw1efobdj4pb3j205002wt8n.jpg)   \n其中专门有一项就是`Log Message`，做个小测试：   \n\n```\nfor (int i = 0; i < 10; i++)\n{\n    // break point here\n}\n```\n\n设置断点后编辑断点：   \n\n![](http://ww2.sinaimg.cn/large/51530583tw1efobktq0vsj20d806r74z.jpg)\n\n输入框下面就有支持的格式，表达式(或变量)可以使用`@exp@`这种格式包起来。于是乎输出：    \n\n```\nbreak at: 'main()',  count: 4, sunnyxx says : 3\nbreak at: 'main()',  count: 5, sunnyxx says : 4\nbreak at: 'main()',  count: 6, sunnyxx says : 5\n```\n正如所料。  \n更多的调试技巧还需要深入研究，不过可以肯定的是，比起单纯的使用`NSLog`，使用好的工具可以让我们debug的效率更高\n\n\n-----\n\n# 总结\n- `NSLog`耗费比较大的资源\n- `NSLog`被设计为error log，是ASL的高层封装\n- 在项目中避免提交commit自己的Debug log，release版本更要注意去除`NSLog`，可以使用自建的log系统或好用的log系统来替代`NSLog`      \n- debug不应只局限于log满天飞，`lldb`断点调试是一个优秀的debug方法，需要再深入研究下\n\n\n-----\n\n\n# References  \nhttps://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/asl.3.html\nhttp://theonlylars.com/blog/2012/07/03/ditching-nslog-advanced-ios-logging-part-1/   \nhttps://github.com/CocoaLumberjack/CocoaLumberjack/wiki/Performance   \nhttps://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/LoggingErrorsAndWarnings.html#//apple_ref/doc/uid/10000172i-SW8-SW1   \nhttp://www.cimgf.com/2012/12/13/xcode-lldb-tutorial/\n\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)","mtime":1398326379000,"source":"_posts/objc_dig_nslog.md","_id":"1eodkmwkzhzusl9q"},"n81v8dbqdse05lhw":{"content":"title: objc kvo的秘密\ndate: 2014-03-09 09:47:04\ntags: objc的秘密\n---\nKVO(Key Value Observing)，是`观察者模式`在`Foundation`中的实现\n\n\n##KVO的原理\n简而言之就是：\n 1. 当一个object有观察者时，动态创建这个object的类的子类\n 2. 对于每个被观察的property，重写其`set`方法\n 3. 在重写的`set`方法中调用`- willChangeValueForKey:`和`- didChangeValueForKey:`通知观察者\n 4. 当一个property没有观察者时，删除重写的方法\n 5. 当没有observer观察任何一个property时，删除动态创建的子类\n\n<!--more-->\n\n空说无凭，简单验证下。\n\n```\n@interface Sark : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n\n@implementation Sark\n@end\n```\n\n```\nSark *sark = [Sark new];\n// breakpoint 1\n[sark addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];\n// breakpoint 2\nsark.name = @\"萨萨萨\";\n[sark removeObserver:self forKeyPath:@\"name\"];\n// breakpoint 3\n```\n断住后分别使用`- class`和`object_getClass()`打出`sark`对象的Class和真实的Class\n```\n// breakpoint 1\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nSark\n\n// breakpoint 2\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nNSKVONotifying_Sark\n\n// breakpoint 3\n(lldb) po sark.class\nSark\n(lldb) po object_getClass(sark)\nSark\n```\n上面的结果说明，在sark对象被观察时，framework使用`runtime`动态创建了一个Sark类的子类`NSKVONotifying_Sark`  \n而且为了隐藏这个行为，NSKVONotifying_Sark重写了`- class`方法返回之前的类，就好像什么也没发生过一样  \n但是使用`object_getClass()`时就暴露了，因为这个方法返回的是这个对象的`isa`指针，**这个指针指向的一定是个这个对象的类对象**  \n\n-----\n\n然后来偷窥一下这个动态类实现的方法，这里请出一个NSObject的扩展`NSObject+DLIntrospection`，它封装了打印一个类的方法、属性、协议等常用调试方法，一目了然。  \n```\n@interface NSObject (DLIntrospection)\n+ (NSArray *)classes;\n+ (NSArray *)properties;\n+ (NSArray *)instanceVariables;\n+ (NSArray *)classMethods;\n+ (NSArray *)instanceMethods;\n\n+ (NSArray *)protocols;\n+ (NSDictionary *)descriptionForProtocol:(Protocol *)proto;\n\n+ (NSString *)parentClassHierarchy;\n@end\n```\n然后继续在刚才的断点处调试：\n```\n// breakpoint 1\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8e9aa00>(\n- (void)setName:(id)arg0 ,\n- (void).cxx_destruct,\n- (id)name\n)\n// breakpoint 2\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8d55870>(\n- (void)setName:(id)arg0 ,\n- (class)class,\n- (void)dealloc,\n- (BOOL)_isKVOA\n)\n// breakpoint 3\n(lldb) po [object_getClass(sark) instanceMethods]\n<__NSArrayI 0x8e9cff0>(\n- (void)setName:(id)arg0 ,\n- (void).cxx_destruct,\n- (id)name\n)\n```\n首先就有个扎眼的`- .cxx_destruct`冒出来，这货是个啥？\n\n> ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed. The visible difference of this with ARC is that Objective-C instance variables are now deallocated after -dealloc in the root class has finished, not before. In most cases, this should make no difference.\n\n[reference from here](http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03)\n\n大概就是说arc下这个方法在所有`dealloc`调用完成后负责释放所有的变量，当然这个和kvo没啥关系了，回到正题。\n从上面breakpoint2的打印可以看出，动态类重写了4个方法：\n1. `- setName:`最主要的重写方法，set值时调用通知函数\n2. `- class`隐藏自己必备啊，返回原来类的class\n3. `- dealloc`做清理犯罪现场工作\n4. `- _isKVOA`这就是内部使用的标示了，判断这个类有没被KVO动态生成子类\n\n-----\n\n接下来验证一下KVO重写set方法后是否调用了`- willChangeValueForKey:`和`- didChangeValueForKey:`  \n最直接的验证方法就是在Sark类中重写这两个方法：\n\n\n```\n@implementation Sark\n\n- (void)willChangeValueForKey:(NSString *)key\n{\n    NSLog(@\"%@\", NSStringFromSelector(_cmd));\n    [super willChangeValueForKey:key];\n}\n\n- (void)didChangeValueForKey:(NSString *)key\n{\n    NSLog(@\"%@\", NSStringFromSelector(_cmd));\n    [super didChangeValueForKey:key];\n}\n\n@end\n```\n没问题。\n\n##KVO深度探究\n![](http://ww4.sinaimg.cn/large/51530583gw1eeb3atvu0ij208z03uaa8.jpg)\n\n```\nnm -a /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.0.sdk/System/Library/Frameworks/Foundation.framework/Foundation | grep KVO\n```\n\n// TODO:\n\n##KVO的硬伤\n###KVO坑爹的API\n// TODO:\n到现在还没有block版本的API？\n###KVO难于调试\n// TODO:\n###KVO的死循环\n// TODO:\n","mtime":1395386344000,"source":"_posts/objc_kvo_secret.md","_id":"n81v8dbqdse05lhw"},"hu2l8s03mnx5j58q":{"content":"title: ios程序员6级考试（答案和解释）\ndate: 2014-03-06 23:10:58\ntags: ios6级考试\n---\n# 我是前言\n上次发了个[ios程序员6级考试题](http://blog.sunnyxx.com/2014/03/06/ios_exam_0/) ，还在不断补充中，开个帖子配套写答案和解释。\n\n------\n\n##1. 下面的代码分别输出什么？  \n\n\n```\n@implementation Son : Father\n- (id)init\n{\n    self = [super init];\n    if (self)\n    {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n@end\n```\n\n答案：都输出\"Son\"  \n解释：objc中`super`是编译器标示符，并不像`self`一样是一个对象，遇到向`super`发的方法时会转译成`objc_msgSendSuper(...)`，而参数中的对象还是`self`，于是从父类开始沿继承链寻找`- class`这个方法，最后在`NSObject`中找到（若无override），此时，`[self class]`和[super class]已经等价了。\n\n<!--more-->\n\n##2. 下面的代码报错？警告？还是正常输出什么？\n```\nFather *father = [Father new];\nBOOL b1 = [father responseToSelector:@selector(responseToSelector:)];\nBOOL b2 = [Father responseToSelector:@selector(responseToSelector:)];\nNSLog(@\"%d, %d\", b1, b2);\n```\n\n答案：都输出\"1\"(YES)  \n解释：objc中：  \n- 不论是实例对象还是Class，都是id类型的对象（Class同样是对象）\n- 实例对象的isa指向它的Class（储存所有减号方法）,Class对象的isa指向元类（储存所有加号方法）\n- 向一个对象（id类型）发送消息时，都是从这个对象的`isa`指针指向的Class中寻找方法\n\n回到题目，当像`Father`类发送一个实例方法（`- responseToSelector`）消息时：\n1. 会从它的`isa`，也就是Father元类对象中寻找，由于元类中的方法都是类方法，所以自然找不到\n2. 于是沿继承链去父类NSObject元类中寻找，依然没有\n3. 由于objc对这块的设计是，NSObject的元类的父类是NSObject类（也就是我们熟悉的NSObject类），其中有所有的实例方法，因此找到了`- responseToSelector`\n\n补充：NSObject类中的所有实例方法`很可能`都对应实现了一个类方法（至少从开源的代码中可以看出来），如`+ resonseToSelector`，但并非公开的API，如果真的是这样，上面到第2步就可以找到这个方法。  \n再补充： 非NSObject的selector这样做无效。\n\n##3. 请求很快就执行完成，但是completionBlock很久之后才设置，还能否执行呢？\n\n```\n...\n// 当前在主线程\n\n[request startAsync]; // 后台线程异步调用，完成后会在主线程调用completionBlock\nsleep(100); // sleep主线程，使得下面的代码在后台线程完成后才能执行\n[request setCompletionBlock:^{\n    NSLog(@\"Can I be printed?\");\n}];\n...\n```\n\n答案：可以（有条件）  \n解释：为了方便解释，我们将其考虑成`gcd`的两个线性`queue`：main queue 和 back queue  \n\n当代码执行到`sleep(100)`时，这两个queue要执行的顺序看起来是这样的：  \n- main: *--- sleep -------------------------> | ---setCompletionBlock--->\n- back: *--- network ---->\n\n于是网络请求很快回来，回调函数一般要执行如：\n```\n// 回到主线程执行回调\ndispatch_async(dispatch_get_main_queue(), ^{\n  if (self.completionBlock) self.completionBlock();\n});\n```\n于是成了这样：  \n\n- main: *----sleep----> | ---setCompletionBlock---> | ---invoke completionBlock---->\n- back: *\n \n所以，当sleep结束后，主线程保持了调用顺序：  \n- main: *---setCompletionBlock---> | ---invoke completionBlock---->  \n\n此时，`completionBlock`的执行是在`setCompletionBlock`，之后的，所以可以正常回调。  \n\n注：这个解释有一个有限制条件，如果用下面的方法回调，则情况就会不同了：  \n```\n// 回到主线程执行回调\nif (self.completionBlock) {\n  dispatch_async(dispatch_get_main_queue(), ^{\n    self.completionBlock();\n});\n\n```\n\n\n##4. 不使用IB时，下面这样做有问题么？\n```\n- (void)viewDidLoad\n{\n  [super viewDidLoad];\n  CGRect frame = CGRectMake(0, 0, self.view.bounds.size.width * 0.5, self.bounds.size.height * 0.5);\n  UIView *view = [[UIView alloc] initWithFrame:frame];\n  [self.view addSubview:view];\n}\n```\n\n解释：不使用IB手动创建ViewController时，在`viewDidLoad`中并未进行位置的初始化，原来遇到过不少次这个小坑，当外部创建这个vc时：  \n```\nTestViewController *vc = [[TestViewController alloc] init];\nvc.view.frame = CGRectMake(0, 0, 100, 100);\n//...\n```\n\n我们知道，`ViewController`的view初始化大概流程是：  \n```\n- (UIView *)view\n{\n  if (!_view) {\n    [self loadView];\n    [self viewDidLoad]; // Edit: 这句话移动到括号内，感谢@change2hao的提醒\n  }\n}\n```\n\n所以在外部执行到`vc.view.frame = CGRectMake(0, 0, 100, 100);`这句话时，在赋值操作执行前，`viewDidLoad`就已经被调用，因而在`viewDidLoad`中对view frame的取值都是默认值（window的大小），而非设定值。  \n\n注： 使用IB加载时如上情况也会发生，只是一般在IB就已经有一个预设值了。  \n\n-----\n\n# 后续题目继续补充中\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](blog.sunnyxx.com)\n\n","mtime":1398131188000,"source":"_posts/ios_exam_0_key.md","_id":"hu2l8s03mnx5j58q"},"evfj3wds771tu6ui":{"content":"title: Reactive Cocoa Tutorial [0] = Overview\ndate: 2014-03-06 21:58:30\ntags: Reactive Cocoa Tutorial\n---\n关于这系列（如果真能写下去的话）：说是教程有点狂，边学边总结，更像个笔记吧，等完全用透之后再写就会忘了一开始学习过程中遇到的问题了，Reactive Cocoa（RAC）现在资料真心少，中文英文加起来没几篇，还都是转来转去的。这是个好东西，相信以后用的人会变多，转了请留该文原地址哦~  by sunny\n<!--more-->\n> PS:\n> 这篇文章原来发布在blogcn上，http://www.cnblogs.com/sunnyxx，\n> 现在建了自己的blog后会在这上面继续写了。\n\n------\n\n###废话少说 --> **RAC**\n\n　　是什么？怎么来的？干啥用的？ 怎么用的？ 可以观摩无网不剩的blog RAC介绍1和2，在此不啰唆了，简而言之，就是一个函数响应式编程思想在Cocoa下的实现。\n\n###说说在RAC框架下做了一个项目的赶脚吧：\n\n - 挺新鲜挺有意思，开发人员水平很高，框架封装性和实用性一流，看了看人家对宏的使用发现原来用的纯小儿科，对编译器的控制，block的使用也很值得的学习。\n - 编程思想上的一些改变。原创的一个可能也不大恰当的比喻：原来的编程思想像是“走迷宫”，RAC的编程思想是“建迷宫”。意思是，之前的编程思路是命令式，大概都是“程序启动时执行xxxx，在用户点击后的回调函数执行xxx，收到一个Notification后执行xxx”等等，如同走迷宫一样，走出迷宫需要在不同时间段记住不同状态根据不同情况而做出一系列反应，继而走出迷宫；相比下，RAC的思想是建立联系，像钟表中的齿轮组一样，一个扣着一个，从转动发条到指针走动，一个齿轮一个齿轮的传导（Reactive），复杂但完整而自然。如同迷宫的建造者，在设计时早已决定了哪里是通路，哪里是死路或是哪个路口指向了出口，当一个挑战者（Event）走入迷宫时（Signal），他一定会在设置好的迷宫中的某个路线行走（传递），继而走到终点（Completion）或困死在里面（Error）。\n - 写出代码结构明显不一样。由于RAC将Cocoa中KVO，UIKit Event，delegate，selector等都增加了RAC支持，所以都不用去做很多跨函数的事，比如KVO个对象然后在回调里面xxx，从storyboard里面连个UIButton的IBAction出来xxx，或是设个UITextField的delegate出来去取输入的文本xxx。但在RAC下就像上面比喻的建迷宫，把这些大都放在“-viewDidLoad:”就可以了，当然像UITableView的delegate和data source这么大规模的代理模式就还是老老实实写吧。\n简洁。举个栗子：\n\n\n\n\n我就想干这么个事:\n\n> 一个label一个text field，下面输啥上面显示啥\n\n\n\n\n\n　　老写法大概做法是这个vc实现UITextFieldDelegate协议，把这个text field的delegate设到vc上面，然后在要改变text的那个delegate方法里面取当前text field的text值，再赋给label上；\n\n使用RAC的话就一句话（当然得把这俩控件都IBOutlet出来）：\n\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal; \n```\n看着就挺爽。\n\n复杂的栗子先不举了。\n\n　　总之吧，等今后维护RAC的开发者和使用者把更多的Cocoa的东西归入RAC的框架中，这个框架基本上都可以凌驾于Cocoa这个框架了，意思是甚至用不着知道那些delegate啊KVO啊苹果告诉你是咋用的，用RAC封装的就行了。RAC对于值的显示大都是和property“绑定”的关系，像使用storyboard构建页面时，对于有响应的控件基本都得IBOutlet出来作为一个property，而不是像原来一样连个IBAction出来或者连个delegate出来。对于视图层到model层之间的绑定就显得有些生硬了，相当于视图直接耦合了model，于是应运而生M-V-VM结构，说白了就是在View和Model之间增加了一个ViewModel来解耦，这样View里面要做的基本就是绑定VM以及一些纯视图的操作（比如用什么动画效果展示一个数据）；VM里面是和View相关的数据部分的储存和操作，比如说一个UITableView的data source，一个对email输入合法性的验证方法，当然还有的是对真正Model层的调用和结果的刷新，由于View已经和VM绑定，这样VM在刷新的时候只刷新自己的属性就得了。\n\n　　其实重要的还是写代码思维方式的变化，如果全工程都使用RAC来实现，对于同一个业务逻辑终于可以在同一块代码里完成了，将UI事件，逻辑处理，文件或数据库操作，异步网络请求，UI结果显示，这一大套统统用函数式编程的思路嵌套起来，进入页面时搭建好这所有的关系，用户点击后妥妥的等着这一套联系一个个的按期望的逻辑和次序触发，最后显示给用户。感觉就像是搭好了一个精致的游乐场，然后不紧不慢地打开大门：@\"Come on 熊孩子们！\"\n\n \n\nPS：写这个blog的时候用的RAC版本是2.2.3，现在RAC3.0-dev正开发中，还会有很多变化，可能没写完就出新了，需要修改的我会update。","mtime":1398131188000,"source":"_posts/rac_0_overview.md","_id":"evfj3wds771tu6ui"},"usoop2ggey1ggeui":{"content":"title: Reactive Cocoa Tutorial [1] = 神奇的Macros\ndate: 2014-03-06 22:11:04\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 -- by sunnyxx\n\n---\n\n##先说说RAC中必须要知道的宏：\n```\nRAC(TARGET, [KEYPATH, [NIL_VALUE]])\n```\n使用：\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\n\nRAC(self.outputLabel, text, @\"收到nil时就显示我\") = self.inputTextField.rac_textSignal;\n```\n　　这个宏是最常用的，`RAC()`总是出现在等号左边，等号右边是一个`RACSignal`，表示的意义是将一个对象的一个`属性`和一个`signal`绑定，signal每产生一个value（id类型），都会自动执行：\n```\n[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];\n```\n　　数字值会升级为`NSNumber *`，当setValue:forKeyPath时会自动降级成基本类型（int, float ,BOOL等），所以RAC绑定一个基本类型的值是没有问题的\n\n<!--more-->\n \n```\n　　· RACObserve(TARGET, KEYPATH)\n```\n　　作用是观察TARGET的KEYPATH属性，相当于`KVO`，产生一个`RACSignal`\n\n　　最常用的使用，和RAC宏绑定属性：\n```\nRAC(self.outputLabel, text) = RACObserve(self.model, name);\n```\n　　上面的代码将label的输出和model的name属性绑定，实现联动，name但凡有变化都会使得label输出\n\n```\n@weakify(Obj);\n@strongify(Obj);\n```\n　　这对宏在 `RACEXTScope.h` 中定义，RACFramework好像没有默认引入，需要单独import\n\n　　**他们的作用主要是在block内部管理对self的引用**：\n```\n@weakify(self); // 定义了一个__weak的self_weak_变量\n[RACObserve(self, name) subscribeNext:^(NSString *name) {\n    @strongify(self); // 局域定义了一个__strong的self指针指向self_weak\n    self.outputLabel.text = name;\n}];\n```\n　　这个宏为什么这么吊，前面加@，其实就是一个啥都没干的@autoreleasepool {}前面的那个@，为了显眼罢了。\n\n　　**这两个宏一定成对出现，先weak再strong**\n\n \n\n##除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。 \n\n \n\n　　举个高级点的栗子：\n\n　　要干的一件事，**计算一个可变参数列表的长度**。\n\n　　第一反应就是用参数列表的api，`va_start` `va_arg` `va_end`遍历一遍计算个和，但仔细想想，对于可变参数这个事，在**编译前**其实就已经确定了，代码里括号里有多少个参数一目了然。\n\n　　RAC中`Racmetamarcos.h`中就有一系列宏来完成这件事，硬是在预处理之后就拿到了可变参数个数：\n```\n#define metamacro_argcount(...) \\\n    metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\n这个宏由几个工具宏一层层展开，现在模拟一下展开过程：\n\n假如我们要计算的如下：\n```\nint count = metamacro_argcount(a, b, c);\n```\n于是乎**第一层**展开后：\n```\nint count = metamacro_at(20, a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\n再看metamacro_at的定义：\n```\n#define metamacro_at(N, ...) metamacro_concat(metamacro_at, N)(__VA_ARGS__)\n// 下面是metamacro_concat做的事（简写一层）\n#define metamacro_concat_(A, B) A ## B\n```\n于是乎**第二层**展开后：\n```\nint count = metamacro_at20(a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);\n```\n再看metamacro_at20这个宏干的事儿：\n```\n#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)\n```\n于是乎**第三层**展开后，相当于截断了前20个参数，留下剩下几个：\n```\nint count = metamacro_head(3, 2, 1);\n```\n这个metamacro_head：\n```\n#define metamacro_head(...) metamacro_head_(__VA_ARGS__, 0)\n#define metamacro_head_(FIRST, ...) FIRST\n```\n　　后面加个0，然后取参数列表第一个，于是乎：\n```\nint count = 3;\n```\n　　**大功告成。**\n\n　　反正我看完之后感觉挺震惊，宏还能这么用，这样带来的好处不止是将计算在预处理时搞定，不拖延到运行时恶心cpu；但更重要的是编译检查。比如某些可变参数的实现要求可以填2个参数，可以填3个参数，其他的都不行，这样，也只有这样的宏的实现，才能在编译前就确定了错误。\n\n##除了上面，还有一个神奇的宏的使用：\n\n　　当使用诸如`RAC(self, outputLabel)`或`RACObserve(self, name)`时，发现写完逗号之后，**输入第二个property的时候会出现完全正确的代码提示**！这相当神奇。\n![自动代码提示][1]\n\n\n探究一下，关键的关键是如下一个宏：\n```\n#define keypath(...) \\\n    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))\n```\n这个`metamacro_argcount`上面说过，是计算**可变参数**个数，所以`metamacro_if_eq`的作用就是判断参数个数，如果个数是1就执行后面的keypath1，若不是1就执行keypath2。\n\n所以重点说一下keypath2：\n```\n#define keypath2(OBJ, PATH) \\\n    (((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n　　乍一看真挺懵，先化简，由于Objc里面keypath是诸如\"outputLabel.text\"的字符串，所以这个宏的返回值应该是个字符串，可以简化成：\n```\n#define keypath2(OBJ, PATH) (???????, # PATH)\n```\n先不管\"??????\"是啥，这里不得不说C语言中一个不大常见的语法（第一个忽略）：\n```\nint a = 0, b = 0;\na = 1, b = 2;\nint c = (a, b);\n```\n这些都是**逗号表达式**的合理用法，第三个最不常用了，c将被b赋值，而a是一个未使用的值，编译器会给出warning。\n\n去除warning的方法很简单，强转成void就行了：\n```\nint c = ((void)a, b);\n```\n再看上面简化的keypath2宏，返回的就是PATH的字符串字面值了(单#号会将传入值转成字面字符串)\n\n```\n(((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n对传入的第一个参数OBJ和第二个正要输入的PATH做了`点`操作，这也正是为什么输入第二个参数时编辑器会给出正确的代码提示。强转void就像上面说的去除了warning。\n\n　但至于为什么加入与`NO`做`&&`，我不太能理解，我测试时其实没有时已经完成了功能，可能是作者为了屏蔽某些隐藏的问题吧。\n\n　　这个宏的巧妙的地方就在于使得编译器以为我们要输入“点”出来的属性，保证了输入值的合法性（输了不存在的property直接报错的），同时利用了逗号表达式取逗号最后值的语法返回了正确的keypath。\n\n \n\n##总之\nRAC对宏的使用达到了很高的水平，还有诸如`RACTuplePack`，`RACTupleUnpack`的宏就不细说了，值得研究。\n\n---\nPS：上面介绍的metamacro和@strongify等宏确切来说来自RAC依赖的extobjc，作者是Justin Spahr-Summers，正是RAC作者之一。\n\n\n  [1]: http://images.cnitblog.com/blog/401798/201402/112147518936541.png","mtime":1398131188000,"source":"_posts/rac_1_macros.md","_id":"usoop2ggey1ggeui"},"522l3acvj2rdljh2":{"content":"title: Reactive Cocoa Tutorial [2] = 百变RACStream\ndate: 2014-03-06 22:34:27\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 -- by sunny\n\n\n##Overview\n\n　　在RAC下开发干的最多的事就是建立RACSignal和subscribe RACSignal了，它是RAC的核心所在。本篇介绍了RAC的运作原理和设计思路，从函数式编程形成的RACStream继而介绍它的子类 - RAC最核心的部分RACSignal。\n\n##函数式编程\n\n　　我们知道Reactive Cocoa是函数式编程(Functional Programing)(FP)思想的实现。FP有一套成熟的理论，这里只讲讲我个人理解吧。\n\n　　我觉得FP就是“**像计算函数表达式一样来解决一个问题**”，举个栗子，中学题：\n\n<!--more-->\n\n```\n已知：f(x) = 2sin(x + π/2)， 求 f(π/2)的值。\n```\n　　其中x是这个函数的输入，f(x)为计算的输出结果，求f(π/2)时给定了x自然能计算出个结果来（说实话我真忘了咋算了）\n\n当然，仔细看这个函数，其实是可以分解成几个小函数的：\n\n```\nf1(x) = x + π/2\nf2(x) = sin(x)\nf3(x) = 2x\n```\n　　而原来的f(x)可以被小函数组合：\n```\nf(x) = f3(f2(f1(x)))\n```\n　　所以不难得出这么个推论：要是我手上有足够的**基本函数**，我就能用上面的组合的方法组合出任意一个**复杂的函数**了。再想想事实上这些年来学数学的过程不就是在一个个积累基本函数的过程嘛，从基本运算，到三角函数，到乘方开方，再到微积分。基本函数越来越多，能解决的数学问题也越来越复杂。\n\n　　再来看一个函数是怎么构成的，FP理论里叫`monads`，十分抽象，没读懂，但能理解出来：一个函数只要有一个对于输入值的运算方法和一个返回值，就够了。也容易理解，给它一个输入，干点事情，给出一个输出，就行了，当然现实情况要复杂得多（比如说输出值本身就是个函数？）有些函数是有输入的条件的，比如原来数学解个函数时候经常跟个作用域或者限制条件，比如`f(x) = 10 / x , (x不为0)`，要是传个0这个函数就认为计算错误。\n\n　　对于像上面栗子的函数，每个函数都能接收上一个函数输出的结果，作为自己的输入，这样才能嵌套生成最终结果，同时，计算的顺序也是一定从里向外，所以换个写法可以写成：\n\n```\nstart ---x--> f1(x) --(temp value1)--> f2(temp value1) --(temp value2)--> f3(temp value2) ---> result\n```\n　　于是乎**嵌套**就被表示成了**序列**，来个高大上的名字怎么样，就叫**流（Stream）**\n\n##RACStream\n\n　　这就是`RACStream`所表示的含义。\n\n　　按照上面说的，其实`RACStream`的名字有点点歧义，对于一个`RACStream`对象，它在意义上等同于上面的f1(x),f2(x),f3(x)，而不是那一大串整体，表示整体的应该是最外层的和f(x)对应的那个对象，叫个RACStreamComponent比较好？理解时候得注意下。\n\n　　所以作为一个基本函数的RACStream应该至少应该有：\n\n 1. 怎么传入值\n 2. 怎么返回值\n 3. 怎么与其他函数组合\n 4. 怎么实现函数的作用域(监测输入值来做处理)\n 5. 这函数叫啥- -\n\n\n得益于在Objc下实现，所以输入输出的“值”都用个`id`类型就行了，遇到多个值的组合就用`RACTurple`（可以把多个值压包和解包，类比WINRAR），1和2解决\n\nRACStream从实例变量来看只有一个`name`，当然它也只应该有个name - -，5解决\n\n　　里面重点问题就是上面的3和4了。由于**函数组合之后仍然是个函数**，所以也很容易理解**两个Stream对象的组合其实就是生成一个新的Stream对**象，它返回了分别由两个子Stream先后运算产生的最终结果\n\n 　　观摩一下RACStream定义的基本方法：\n```\n+ (instancetype)empty;\n+ (instancetype)return:(id)value;\n- (instancetype)bind:(RACStreamBindBlock (^)(void))block; // for 4\n- (instancetype)concat:(RACStream *)stream; // for 3\n- (instancetype)zipWith:(RACStream *)stream; // for 3\n```\n　　RACStream作为一个描述抽象的父类，这几个基本方法并没有实现，是由具体子类来实现，RACStream的两个子类分别是`RACSignal`和`RACSequence`\n\n　　\n\n - `+empty` 是一个不返回值，立刻结束(Completed)的函数，意思是执行它之后除了立刻结束啥都不会发生，可以理解为RAC里面的nil。\n\n\n\n - `+return:` 是一个直接返回给定值，然后立刻结束的函数，比如 f(x) = 213\n\n - `-bind:`是一个非常重要的函数，在Rac Doc中被描述为‘**basic primitives, particularly**’，它是RACStream监测“值”和控制“运行状态”的基本方法，个人认为看注释文档不能理解它是干嘛的，而且bind英语“捆绑，绑定，强迫，约束”这几个意思也感觉对不上，我觉得叫“**绑架**”倒是更贴切一点。在-bind：之后，之前的RACStream就处于被“绑架”的状态，被绑架的RACStream每产生一个值，都要经过“绑架者”来决定：\n\n1. 是否使这个RACStream结束（被绑架者是否还能继续活着）\n\n2. 用什么新的RACStream来替换被绑架的RACStream，传出的结果也成了新RACStream产生的值（绑匪可以选择再抓一个人质放之前那个前面）\n\n 　　举个具体栗子，RACStream的 - take：方法，这个方法使一个RACStream只取前N次的值（有缩减）：\n\n```\n- (instancetype)take:(NSUInteger)count {\n    Class class = self.class;\n    \n    return [[self bind:^{ // self被绑架\n        __block NSUInteger taken = 0;\n\n        return ^ id (id value, BOOL *stop) { // 这个block在被绑架的self每输出一个值得时候触发\n            RACStream *result = class.empty;\n\n            if (taken < count) result = [class return:value]; // 未达到N次时将原值原原本本的传递出去\n            if (++taken >= count) *stop = YES; // 达到第N次值后干掉了被绑架的self\n\n            return result; // 将被绑架的self替换为result\n        };\n    }]];\n}\n```\n 　　`-concat:` 和 `-zipWith:` 就是将两个RACStream连接起来的基本方法了：\n\n`[A concat:B]`中A和B像`皇上`和`太子`的关系，A是皇上，B是太子。皇上健在的时候统治天下发号施令（value），太子就候着，不发号施令（value），当皇上挂了（completed），太子登基当皇上，此时发出的号令（value）是太子的。\n`[C zipWith:D]`可以比喻成一对`平等恩爱的夫妻`，两个人是“绑在一起“的关系来组成一个家庭，决定一件事（value）时必须两个人都提出意见（当且仅当C和D同时都产生了值的时候，一个value才被输出，CD只有其中一个有值时会挂起等待另一个的值，所以输出都是一对值（RACTuple）），当夫妻只要一个人先挂了（completed）这个家庭（组合起来的RACStream）就宣布解散（也就是无法凑成一对输出时就终止）\n##然后呢？\n\n　　除了上面几个基本方法，RACStream还有不少的Operation方法，这些操作方法的实现大都是组合基本的方法来达到特定的目的，虽然是RACStream这个基类实现的，但我觉得还是放在后面介绍RACSignal的时候作为它的使用方法来说比较合适，毕竟绝大多数编程的对象的都是RACStream的两个子类，后面再展开介绍好了。\n\n","mtime":1398131188000,"source":"_posts/rac_2_racstream.md","_id":"522l3acvj2rdljh2"},"k9dpm4vxoiglnaj3":{"content":"title: ARC下dealloc过程及.cxx_destruct的探究\ndate: 2014-04-02 16:39:00\ntags: objc刨根问底\n---\n\n## 我是前言  \n这次探索源自于自己一直以来对`ARC`的一个疑问，在`MRC`时代，经常写下面的代码：  \n\n```\n- (void)dealloc\n{\n    self.array = nil;\n    self.string = nil;\n    // ... //\n    // 非Objc对象内存的释放，如CFRelease(...)\n    // ... //\n    [super dealloc];\n}\n```\n\n对象析构时将内部其他对象`release`掉，申请的非Objc对象的内存当然也一并处理掉，最后调用`super`，继续将父类对象做析构。而现如今到了`ARC`时代，只剩下了下面的代码：\n\n```\n- (void)dealloc\n{\n    // ... //\n    // 非Objc对象内存的释放，如CFRelease(...)\n    // ... //\n}\n```\n\n**问题来了：**  \n\n  1. 这个对象实例变量（Ivars）的释放去哪儿了？ \n  2. 没有显示的调用`[super dealloc]`，上层的析构去哪儿了？ \n\n\n------\n\n<!--more-->\n## ARC文档中对dealloc过程的解释\n \n[llvm官方的ARC文档](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc)中对ARC下的dealloc过程做了简单说明，从中还是能找出些有用的信息： \n\n  >A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.\n\n - 大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，**父类的dealloc的方法将在子类dealloc方法返回后自动调用**\n\n\n  > The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.\n\n - 理解：ARC下对象的实例变量在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）\n\n所以，不用主调`[super dealloc]`是因为自动调了，后面再说如何实现的；ARC下实例变量在根类NSObject析构时析构，下面就探究下。\n\n------\n\n## NSObject的析构过程\n通过apple的runtime源码，不难发现NSObject执行`dealloc`时调用`_objc_rootDealloc`继而调用`object_dispose`随后调用`objc_destructInstance`方法，前几步都是条件判断和简单的跳转，最后的这个函数如下：\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n        \n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n```\n\n简单明确的干了三件事：\n  1. 执行一个叫`object_cxxDestruct`的东西干了点什么事\n  2. 执行`_object_remove_assocations`去除和这个对象assocate的对象（常用于category中添加带变量的属性，这也是为什么~~<strike>ARC下没必要remove一遍的原因~~</strike> (Edit: 在ARC或MRC下都不需要remove，感谢@sagles的基情提示）\n  3. 执行`objc_clear_deallocating`，清空引用计数表并清除弱引用表，将所有`weak`引用指nil（这也就是weak变量能安全置空的所在）\n\n所以，所探寻的ARC自动释放实例变量的地方就在`cxxDestruct`这个东西里面没跑了。\n\n------\n\n## 探寻隐藏的.cxx_destruct\n\n上面找到的名为`object_cxxDestruct`的方法最终成为下面的调用：\n\n```\nstatic void object_cxxDestructFromClass(id obj, Class cls)\n{\n    void (*dtor)(id);\n\n    // Call cls's dtor first, then superclasses's dtors.\n\n    for ( ; cls != NULL; cls = _class_getSuperclass(cls)) {\n        if (!_class_hasCxxStructors(cls)) return; \n        dtor = (void(*)(id))\n            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);\n        if (dtor != (void(*)(id))_objc_msgForward_internal) {\n            if (PrintCxxCtors) {\n                _objc_inform(\"CXX: calling C++ destructors for class %s\", \n                             _class_getName(cls));\n            }\n            (*dtor)(obj);\n        }\n    }\n}\n```\n\n代码也不难理解，沿着继承链逐层向上搜寻`SEL_cxx_destruct`这个selector，找到函数实现(`void (*)(id)`(函数指针)并执行。  \n搜索这个selector的声明，发现是名为`.cxx_destruct`的方法，以点开头的名字，我想和unix的文件一样，是有**隐藏**属性的\n\n从[这篇文章](http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03)中：\n  >ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed. \n\n和《Effective Objective-C 2.0》中提到的：\n  >When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.  \n\n可以了解到，`.cxx_destruct`方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作\n\n-----\n\n## 通过实验找出.cxx_destruct  \n最好的办法还是写个测试代码把这个隐藏的方法找出来，其实在runtime中运行已经没什么隐藏可言了，简单的类结构如下：\n\n```\n@interface Father : NSObject\n@property (nonatomic, copy) NSString *name;\n@end\n\n@interface Son : Father\n@property (nonatomic, copy) NSArray *toys;\n@end\n```\n\n只有两个简单的属性，找个地方写简单的测试代码：\n\n```\n    // start\n    {\n        // before new\n        Son *son = [Son new];\n        son.name = @\"sark\";\n        son.toys = @[@\"sunny\", @\"xx\"];\n        // after new\n    }\n    // gone\n```\n\n主要目的是为了让这个对象走dealloc方法，新建的son对象过了大括号作用域就会释放了，所以在`after new`这行son对象初始化完成，在`gone`这行son对象被dealloc  \n\n个人一直喜欢使用[NSObject+DLIntrospection](https://github.com/garnett/DLIntrospection)这个扩展作为调试工具，可以轻松打出一个类的方法，变量等等。  \n\n将这个扩展引入工程内，在`after new`处设置一个断点，run，trigger后使用lldb命令用这个扩展输出Son类所有的方法名：\n\n![](http://ww3.sinaimg.cn/large/51530583gw1ef27srhw7lj208b05ujrq.jpg)\n\n发现了这个`.cxx_destruct`方法，经过几次试验，发现：\n  1. 只有在ARC下这个方法才会出现（试验代码的情况下）\n  2. 只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法\n  3. 出现这个方法和变量是否被赋值，赋值成什么没有关系\n\n-----\n\n## 使用watchpoint定位内存释放时刻\n\n依然在`after new`断点处，输入lldb命令：\n```\nwatchpoint set variable son->_name\n```\n将`name`的变量加入watchpoint，当这个变量被修改时会触发trigger：\n\n![](http://ww3.sinaimg.cn/large/51530583gw1ef28rn41lcj20fs03aq3b.jpg)\n\n从中可以看出，在这个时刻，`_name`从0x00006b98变成了0x0，也就是nil，赶紧看下调用栈：\n\n![](http://ww1.sinaimg.cn/large/51530583gw1ef2911o40zj20a605yweu.jpg)\n\n发现果然跟到了`.cxx_destruct`方法，而且是在`objc_storeStrong`的过程中释放\n\n-----\n\n## 刨根问底.cxx_destruct\n\n知道了ARC下对象实例变量的释放过程在`.cxx_destruct`内完成，但这个函数内部发生了什么，是如何调用`objc_storeStrong`释放变量的呢？  \n从上面的探究中知道，`.cxx_destruct`是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的`Code Generation`，因为之前曾经使用`clang -rewrite-objc xxx.m`时查看过官方文档留下了些印象，于是google：\n\n```\n.cxx_destruct site:clang.llvm.org\n```\n\n结果发现clang的`doxygen`文档中`CodeGenModule`模块正是这部分的实现代码，cxx相关的代码生成部分源码在  \nhttp://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html  \n位于1827行，删减掉离题部分如下：  \n\n\n```\n/// EmitObjCIvarInitializations - Emit information for ivar initialization\n/// for an implementation.\nvoid CodeGenModule::EmitObjCIvarInitializations(ObjCImplementationDecl *D) \n{\n    DeclContext* DC = const_cast<DeclContext*>(dyn_cast<DeclContext>(D));\n    assert(DC && \"EmitObjCIvarInitializations - null DeclContext\");\n    IdentifierInfo *II = &getContext().Idents.get(\".cxx_destruct\");\n    Selector cxxSelector = getContext().Selectors.getSelector(0, &II);\n    ObjCMethodDecl *DTORMethod = ObjCMethodDecl::Create(getContext(), \n                                                        D->getLocation(),\n                                                        D->getLocation(), cxxSelector,\n                                                        getContext().VoidTy, 0, \n                                                        DC, true, false, true,\n                                                        ObjCMethodDecl::Required);\n   D->addInstanceMethod(DTORMethod);\n   CodeGenFunction(*this).GenerateObjCCtorDtorMethod(D, DTORMethod, false);\n}\n```\n\n这个函数大概作用是：获取`.cxx_destruct`的selector，创建Method，并加入到这个Class的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于  \nhttp://clang.llvm.org/doxygen/CGObjC_8cpp_source.html  \n1354行，包含了构造和析构的cxx方法，继续跟随`.cxx_destruct`，最终调用`emitCXXDestructMethod`函数，代码如下：  \n\n```\nstatic void emitCXXDestructMethod(CodeGenFunction &CGF, ObjCImplementationDecl *impl) \n{\n   CodeGenFunction::RunCleanupsScope scope(CGF);\n \n   llvm::Value *self = CGF.LoadObjCSelf();\n \n   const ObjCInterfaceDecl *iface = impl->getClassInterface();\n   for (const ObjCIvarDecl *ivar = iface->all_declared_ivar_begin(); ivar; ivar = ivar->getNextIvar()) \n   {\n     QualType type = ivar->getType();\n\n     // Check whether the ivar is a destructible type.\n     QualType::DestructionKind dtorKind = type.isDestructedType();\n     if (!dtorKind) continue;\n \n     CodeGenFunction::Destroyer *destroyer = 0;\n \n     // Use a call to objc_storeStrong to destroy strong ivars, for the\n     // general benefit of the tools.\n     if (dtorKind == QualType::DK_objc_strong_lifetime) {\n       destroyer = destroyARCStrongWithStore;\n \n     // Otherwise use the default for the destruction kind.\n     } else {\n       destroyer = CGF.getDestroyer(dtorKind);\n     }\n \n     CleanupKind cleanupKind = CGF.getCleanupKind(dtorKind);\n     CGF.EHStack.pushCleanup<DestroyIvar>(cleanupKind, self, ivar, destroyer,\n                                          cleanupKind & EHCleanup);\n   }\n \n   assert(scope.requiresCleanups() && \"nothing to do in .cxx_destruct?\");\n}\n```\n\n分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用`objc_storeStrong`，从`clang`的ARC文档上可以找到`objc_storeStrong`的示意代码实现如下：\n\n```\nid objc_storeStrong(id *object, id value) {\n  value = [value retain];\n  id oldValue = *object;\n  *object = value;\n  [oldValue release];\n  return value;\n}\n```\n\n在`.cxx_destruct`进行形如`objc_storeStrong(&ivar, null)`的调用后，这个实例变量就被`release`和设置成`nil`了  \n注：真实的实现可以参考 http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html 2078行\n\n-----\n\n## 自动调用[super dealloc]的实现  \n按照上面的思路，自动调用`[super dealloc]`也一定是`CodeGen`干的工作了 \n位于 http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html 492行  \n`StartObjCMethod`方法中：  \n\n```\n if (ident->isStr(\"dealloc\"))\n    EHStack.pushCleanup<FinishARCDealloc>(getARCCleanupKind()); \n```\n\n上面代码可以得知在调用`dealloc`方法时被插入了代码，由`FinishARCDealloc`结构定义：  \n\n```\nstruct FinishARCDealloc : EHScopeStack::Cleanup {\n   void Emit(CodeGenFunction &CGF, Flags flags) override {\n     const ObjCMethodDecl *method = cast<ObjCMethodDecl>(CGF.CurCodeDecl);\n \n     const ObjCImplDecl *impl = cast<ObjCImplDecl>(method->getDeclContext());\n     const ObjCInterfaceDecl *iface = impl->getClassInterface();\n     if (!iface->getSuperClass()) return;\n \n     bool isCategory = isa<ObjCCategoryImplDecl>(impl);\n \n     // Call [super dealloc] if we have a superclass.\n     llvm::Value *self = CGF.LoadObjCSelf();\n \n     CallArgList args;\n     CGF.CGM.getObjCRuntime().GenerateMessageSendSuper(CGF, ReturnValueSlot(),\n                                                       CGF.getContext().VoidTy,\n                                                       method->getSelector(),\n                                                       iface,\n                                                       isCategory,\n                                                       self,\n                                                       /*is class msg*/ false,\n                                                       args,\n                                                       method);\n   }\n};\n```\n\n上面代码基本上就是向父类转发`dealloc`的调用，实现了自动调用`[super dealloc]`方法。  \n\n-----\n## 总结  \n\n  - ARC下对象的成员变量于编译器插入的`.cxx_desctruct`方法自动释放\n  - ARC下`[super dealloc]`方法也由编译器自动插入\n  - 所谓`编译器插入代码`过程需要进一步了解，还不清楚其运作方式\n  - clang的`CodeGen`也值得深入研究一下\n\n-----\n\n## References： \n - http://clang.llvm.org/docs/AutomaticReferenceCounting.html\n - http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03\n - http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html\n\n-----\n\n原创文章，转载请注明源地址，[blog.sunnyxx.com](http://blog.sunnyxx.com)\n\n","mtime":1398146554000,"source":"_posts/objc_dig_arc_dealloc.md","_id":"k9dpm4vxoiglnaj3"},"zu0fg1zqtgz8rmoj":{"content":"title: 使用Sublime Text写Markdown\ndate: 2014-03-16 13:58:03\ntags: 开发工具\n---\n\n默认Sublime Text是不支持Markdown语法高亮和预览的，对于万能的Sublime Text，这点事情一定有插件能解决。  \n\nSublime Text 3 安装`Package Control`，挺不能理解为什么不默认含在app里  \n快捷键**ctrl+`**或者 View > Show Console 菜单打开控制台\n```\nimport urllib.request,os;\npf='Package Control.sublime-package';\nipp=sublime.installed_packages_path();\nurllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));\nopen(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())\n```\n安好重启后，用万能快捷键`Ctrl+Shift+P`，调出菜单`Package Control Install`，再输入`Markdown`关键字，就能发现很多Markdown插件。  \n经过反复尝试，还是一个叫`Markdown Editing`的比较好使，直接使编辑器在编辑时所见即所得，只是这个默认灰色的颜色...\n<!-- more -->\n![](http://ww4.sinaimg.cn/large/51530583gw1eehp8t8zkfj20r60jzgo9.jpg)","mtime":1395386344000,"source":"_posts/sublime_text_markdown.md","_id":"zu0fg1zqtgz8rmoj"},"0y4ds56h8eehquo1":{"content":"layout: objc\ntitle: objc category的秘密\ndate: 2014-03-05 17:37:19\ntags: objc的秘密\n---\n\n##category的真面目\nobjc所有类和对象都是c结构体，category当然也一样，下面是`runtime`中category的结构：\n``` objc\nstruct _category_t {\n\tconst char *name; // 1\n\tstruct _class_t *cls; // 2\n\tconst struct _method_list_t *instance_methods; // 3\n\tconst struct _method_list_t *class_methods; // 4\n\tconst struct _protocol_list_t *protocols; // 5\n\tconst struct _prop_list_t *properties; // 6\n};\n```\n<!--more-->\n 1. `name`注意，并不是category小括号里写的名字，而是类的名字\n 2. `cls`要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据`name`对应到类对象\n 3. `instance_methods`这个category所有的`-`方法\n 4. `class_methods`这个category所有的`+`方法\n 5. `protocols`这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的\n 6. `properties`这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会`@synthesize`实例变量，一般有需求添加实例变量属性时会采用`objc_setAssociatedObject`和`objc_getAssociatedObject`方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。\n\n###编译器，你对category干了什么？\n\n举个栗子看，定义下面一个类和它的category，实现忽略，保存为`sark.h`和`sark.m`\n``` objc\n@interface Sark : NSObject\n- (void)speak;\n@end\n\n@interface Sark (GayExtention)\n- (void)burst;\n@end\n```\n请出clang的重写命令：\n``` bash\n$ clang -rewrite-objc sark.m\n```\n同级目录下会生成`sark.cpp`，这就是`objc`代码重写成`c++`(基本就是c)的实现。\n打开生成的文件，发现茫茫多，排除include进来的header，自己的代码都在文件尾部了，看看上面的category被编译器搞成什么样子了：\n``` c\nstatic struct _category_t _OBJC_$_CATEGORY_Sark_$_GayExtention __attribute__ ((used, section (\"__DATA,__objc_const\"))) =\n{\n\t\"Sark\",\n\t0, // &OBJC_CLASS_$_Sark,\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention,\n\t0,\n\t0,\n\t0,\n};\n```\n先注意这个category的名字`_OBJC_$_CATEGORY_Sark_$_GayExtention`，这是一个按规则生成的符号了，中间的`Sark`是类名，后面的`GayExtention`是类别的名字，这也就是为什么**同一个类的category名不能冲突**了  \n\n对应看上面`_category_t`的定义，因为category里面只添加了一个`- burst`方法，所以只有实例方法那一项被填充了值`_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention`\n\n其中`_I_Sark_GayExtention_burst`符号就代表了category里面的`- burst`方法，同样遵循了一定的命名规范，里面的`I`表示实例方法\n\n最后，这个类的category们生成了一个数组，存在了`__DATA`段下的`__objc_catlist`section里\n``` c\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n\t&_OBJC_$_CATEGORY_Sark_$_GayExtention,\n};\n```\n至此编译器的任务完成了。\n\n###runtime，我的category哪儿去了？\n\n我们知道，category动态扩展了原来类的方法，在调用者看来好像原来类本来就有这些方法似的，有两个事实：\n\n 1. 不论有没有import category 的`.h`，都可以成功调用category的方法，都影响不到category的加载流程，import只是帮助了编译检查和链接过程\n 2. runtime加载完成后，category的**原始信息**在**类结构里**将不会存在\n\n\n这需要探究下**runtime对category的加载过程**，这里就简单说一下\n\n 1. objc runtime的加载入口是一个叫`_objc_init`的方法，在library加载前由libSystem dyld调用，进行初始化操作\n 2. 调用`map_images`方法将文件中的`image`map到内存\n 3. 调用`_read_images`方法初始化map后的`image`，这里面干了很多的事情，像load所有的类、协议和**category**，著名的`+ load`方法就是这一步调用的\n 4. 仔细看category的初始化，循环调用了`_getObjc2CategoryList`方法，这个方法拿出来看看：\n 5. ...\n\n\n``` objc\n#define GETSECT(name, type, sectname)                                   \\\n    type *name(const header_info *hi, size_t *outCount)  \\\n    {                                                                   \\\n        unsigned long byteCount = 0;                                    \\\n        type *data = (type *)                                           \\\n            getsectiondata(hi->mhdr, SEG_DATA, sectname, &byteCount);   \\\n        *outCount = byteCount / sizeof(type);                           \\\n        return data;                                                    \\\n    }\n\n// ... //\n\nGETSECT(_getObjc2CategoryList, category_t *, \"__objc_catlist\");\n```\n眼熟的`__objc_catlist`，就是上面category存放的数据段了，可以串连起来了\n\n在调用完`_getObjc2CategoryList`后，runtime终于开始了**category的处理**，简化的代码如下\n``` objc\n// Process this category.\n// First, register the category with its target class.\n// Then, rebuild the class's method lists (etc) if\n// the class is realized.\nBOOL classExists = NO;\nif (cat->instanceMethods ||  cat->protocols  ||  cat->instanceProperties)\n{\n    addUnattachedCategoryForClass(cat, cls, hi);\n    if (isRealized(cls)) {\n        remethodizeClass(cls);\n        classExists = YES;\n    }\n}\n\nif (cat->classMethods  ||  cat->protocols )\n{\n    addUnattachedCategoryForClass(cat, cls->isa, hi);\n    if (isRealized(cls->isa)) {\n        remethodizeClass(cls->isa);\n    }\n}\n```\n首先分成两拨，一拨是实例对象相关的调用`addUnattachedCategoryForClass`，一拨是类对象相关的调用`addUnattachedCategoryForClass`，然后会调到`attachCategoryMethods`方法，这个方法把一个类所有的category_list的所有方法取出来组成一个`method_list_t **`，注意，这里是`倒序`添加的，也就是说，新生成的category的方法会先于旧的category的方法插入\n```\nstatic void\nattachCategoryMethods(class_t *cls, category_list *cats,\n                      BOOL *inoutVtablesAffected)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    BOOL isMeta = isMetaClass(cls);\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);\n\n    _free_internal(mlists);\n\n}\n```\n生成了所有method的list之后，调用`attachMethodLists`将所有方法`前序`添加进类的方法的数组中，也就是说，如果原来类的方法是a,b,c，类别的方法是1,2,3，那么插入之后的方法将会是1,2,3,a,b,c，也就是说，原来类的方法被category的方法`覆盖`了，但被覆盖的方法确实还在那里。\n","mtime":1394433927000,"source":"_posts/objc_category_secret.md","_id":"0y4ds56h8eehquo1"},"bygcduj9yz8lsn9s":{"content":"title: Reactive Cocoa Tutorial [3] = RACSignal的巧克力工厂\ndate: 2014-03-06 22:45:43\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/  -- by sunnyxx\n\n##Overview\n\n　　上一篇介绍了函数式编程和`RACStream`，使得函数得以串联起来，而它的具体子类，也是RAC编程中最重要的部分，`RACSignal`就是使得算式得以逐步运算并使其有意义的关键所在，本节主要介绍`RACSignal`的机理，具体的使用放到接下来的几节。\n\n\n<img src=\"http://pic.jschina.com.cn/0/12/03/96/12039600_602173.jpg\" width=\"400px\"/>\n\n\n##巧克力工厂的运作模式\n\n　　RACStream实现了一个嵌套函数的结构，如f(x) = f1(f2(f3(x)))，但好像是考试卷子上的一道题，没有人去做它，没得出个结果的话这道题是没有意义的。\n\n<!--more-->\n\n　　OK，现在起将这个事儿都比喻成一个巧克力工厂，f(x)的结果是一块巧克力，f1,f2,f3代表巧克力生产的几个步骤，如果这个工厂不开工，它是没有意义的。\n\n　　再说RACSignal，引用RAC doc的描述：\n　　\n> “A signal, represented by the RACSignal class, is a push-driven\n> stream.”\n\n　　我觉得这个`push-driven`要想解释清楚，需要和RACSequence的`pull-driven`放在一起来看。在巧克力工厂，push-driven是“生产一个吃一个”，而pull-driven是“吃完一个才生产下一个”，对于工厂来说前者是主动模式：生产了巧克力就“push”给各个供销商，后者是被动模式：各个供销商过来“pull”产品时才给你现做巧克力。\n\n###Status\n\n　　所以，对于RACSigna的push-driven的生产模式，首先，当工厂发现没有供销商签合同准备要巧克力的时候，工厂当然没有必要开动生产；只要当有一个以上准备收货的经销商时，工厂才开动生产。这就是RACSignal的休眠（cold）和激活（hot）状态，也就是所谓的冷信号和热信号。一般情况下，一个RACSignal创建之后都处于cold状态，有人去subscribe才被激活。\n\n###Event\n\n　　RACSignal能产生且只能产生三种事件：next、completed，error。\n\n　　next表示这个Signal产生了一个值（成功生产了一块巧克力）\n\n　　completed表示Signal结束，结束信号只标志成功结束，不带值（一个批次的订单完成了）\n\n　　error表示Signal中出现错误，立刻结束（一个机器坏了，生产线立刻停止运转）\n\n　　工厂厂长存了所有供销商的QQ，每当发生上面三件事情的一件时，都用QQ挨个儿发消息告诉他们，于是供销商就能根据生产状态决定要做点什么。当订单完成或者失败后，厂长就会把这个供销商的QQ删了，以后发消息的时候也就没必要通知他了。\n\n###Side Effects\n\n　　RACSignal在被subscribe的时候可能会产生副作用，先举个官方的栗子：\n\n```\n__block int aNumber = 0;\n\n// Signal that will have the side effect of incrementing `aNumber` block\n// variable for each subscription before sending it.\nRACSignal *aSignal = [RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n    aNumber++;\n    [subscriber sendNext:@(aNumber)];\n    [subscriber sendCompleted];\n    return nil;\n}];\n\n// This will print \"subscriber one: 1\"\n[aSignal subscribeNext:^(id x) {\n    NSLog(@\"subscriber one: %@\", x);\n}];\n\n// This will print \"subscriber two: 2\"\n[aSignal subscribeNext:^(id x) {\n    NSLog(@\"subscriber two: %@\", x);\n}];\n```\n　　上面的signal在作用域外部引用了一个int变量，同时在signal的运算过程中作为`next`事件的值返回，这就造成了所谓的`副作用`，因为第二个订阅者的订阅而影响了输出值。\n\n　　我的理解来看，这个事儿做的就不太地道，一个正经的函数式编程中的函数是不应该因为进行了运算而导致后面运算的值不统一的。但对于实际应用的情况来看也到无可厚非，比如用户点击了“登录”按钮，编程时把登录这个业务写为一个login的RACSignal，当然，第一次调用登录和再点一次第二次调用登录的结果肯定不一样了。所以说RAC式编程减少了大部分对临时状态值的定义，但不是全部哦。\n\n　　怎么办呢？我觉得最好的办法就是“约定”，RAC design guide里面介绍了对于一个signal的命名法则：\n\n    Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。\n    Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是个啥（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型）\n    Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用\n\n　　当然，也可以`multicast`一个event，使得某些特殊的情况来共享一个副作用，后面再具体讲，先一个官方的简单的栗子：\n\n```\n// This signal starts a new request on each subscription.\nRACSignal *networkRequest = [RACSignal createSignal:^(id<RACSubscriber> subscriber) {\n    AFHTTPRequestOperation *operation = [client\n        HTTPRequestOperationWithRequest:request\n        success:^(AFHTTPRequestOperation *operation, id response) {\n            [subscriber sendNext:response];\n            [subscriber sendCompleted];\n        }\n        failure:^(AFHTTPRequestOperation *operation, NSError *error) {\n            [subscriber sendError:error];\n        }];\n\n    [client enqueueHTTPRequestOperation:operation];\n    return [RACDisposable disposableWithBlock:^{\n        [operation cancel];\n    }];\n}];\n\n// Starts a single request, no matter how many subscriptions `connection.signal`\n// gets. This is equivalent to the -replay operator, or similar to\n// +startEagerlyWithScheduler:block:.\nRACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];\n[connection connect];\n\n[connection.signal subscribeNext:^(id response) {\n    NSLog(@\"subscriber one: %@\", response);\n}];\n\n[connection.signal subscribeNext:^(id response) {\n    NSLog(@\"subscriber two: %@\", response);\n}];\n```\n　　当地一个订阅者subscribeNext的时候触发了AFNetworkingOperation的创建和执行，开始网络请求，此时又来了个订阅者订阅这个Signal，按理说这个网络请求会被“副作用”，重新发一遍，但做了上面的处理之后，这两个订阅者接收到了同样的一个请求的内容。\n\n###RACScheduler - 生产线\n\n　　RACScheduler是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行，不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了，有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。\n\n　　但值得特殊了解的事实是：\n\n    However, RAC guarantees that no two signal events will ever arrive concurrently. While an event is being processed, no other events will be delivered. The senders of any other events will be forced to wait until the current event has been handled.\n\n　　意思是订阅者执行时的block一定非并发执行，也就是说不会执行到一半被另一个线程进入，也意味着写subscribeXXX block的时候没必要做加锁处理了。\n\n###巧克力的生产工艺\n\n　　RACSignal的厂子建好了，运行的模式也都想好了，剩下的就是巧克力的加工工艺了。\n\n　　有了RACStream的嵌套和组装的基础，RACSignal得以使用组件化的工艺来一步步的加工巧克力，从可可，牛奶，糖等原料，混合到这种巧克力适用的液态巧克力，过滤，提纯，冷却，夹心，压模，再到包装，一个巧克力就产出了。对于不同种类的巧克力，比如酒心巧克力，也不过是把其中的某个组件替换成注入酒心罢了。\n\n　　RACSignal的生产组件，也就是它的各式各样的operation，一个具体业务逻辑的实现，其实也就是选择合适operation按合适的顺序组合起来。\n\n　　还举那个用户在textFiled输入并显示到上面的label中的栗子:\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\n```\n　　现在需求变成“用户输入3个字母以上才输出到label，当不足3个时显示提示”，OK，好办：\n```\nRAC(self.outputLabel, text) = [[self.inputTextField.rac_textSignal\n    startWith:@\"key is >3\"] /* startWith 一开始返回的初始值 */\n    filter:^BOOL(NSString *value) {\n        return value.length > 3; /* filter使满足条件的值才能传出 */\n}];\n\n```\n　　需求又增加成“**当输入sunny时显示输入正确**”\n\n```\nRAC(self.outputLabel, text) = [[self.inputTextField.rac_textSignal\n    startWith:@\"key is >3\"] // startWith 一开始返回的初始值\n    filter:^BOOL(NSString *value) { // filter使满足条件的值才能传出\n        return value.length > 3;\n    }]\n    map:(NSString *value) {　// map将一个值转化为另一个值输出\n        return [value isEqualToString:@\"sunny\"] ? @\"bingo!\" : value;\n    }];\n\n```\n　　可以看出，基本上一个业务逻辑经过分析后可以拆解成一个个小RACSignal的组合，也就像生产巧克力的一道道工艺了。上面的栗子慢慢感觉就像了一个简陋的输答案的框了。\n\n###然后呢？\n\n　　接下来的几节就具体介绍一下RACSignal的operation方法，RAC提供了很多操作方法，大概总结为几大类：过滤型、XXX型、XXX型，后面再慢慢道来。\n","mtime":1398131188000,"source":"_posts/rac_3_racsignal.md","_id":"bygcduj9yz8lsn9s"},"9uq86nvpgle077l9":{"content":"title: Reactive Cocoa Tutorial [4] = 只取所需的Filters\ndate: 2014-04-19 09:30:28\ntags: Reactive Cocoa Tutorial\n---\n\n#我是前言\n这是[Reactive Cocoa Tutorial系列](http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/)其中的一篇，[上一篇](http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/)简单介绍了RAC中最重要的`RACSignal`，下面几篇文章将主要从它的`Operations`下手，这也是工程中使用RAC的重点。从简到难，本篇文章先介绍RAC消息流的`过滤器-Filters`类别的相关方法。\n\n<!--more-->\n\n-----\n\n#RAC中的Filters\n\n##画个范围\n一个Signal源可以产生一系列next值，但并非所有值都是需要的，具体的Subscriber可以选择在原有Signal上套用Filter操作来过滤掉不需要的值。  \n我的定义：RAC中如果一个`Operation`将处理后的值集合是处理前值集合的`子集`，我们就可以把它归为`Filter`类型。  \n\n当然通过之前介绍的基础操作完全可以自己拼出个想要的filter来，RAC为了方便使用已经实现了几个常用的filter，经过总结，这些filter大概可以分成两类：`next值过滤类型`和`起止点过滤类型`\n\n##值过滤类型Filters\n### - filter: (BOOL (^)(id value))\nRAC中的filter同名方法`- filter:(BOOL (^)(id value))`，简单明了，将一个value用block做test，返回YES的才会通过，它的内部实现使用了`- flattenMap:`，将原来的`Signal`经过过滤转化成只返回过滤值的`Signal`，用法也不难理解：    \n\n```\n[[self.inputTextField.rac_textSignal filter:^BOOL(NSString *value) {\n    return [value hasPrefix:@\"sunny\"];\n}] subscribeNext:^(NSString *value) {\n    NSLog(@\"This value has prefix `sunny` : %@\", value);\n}];\n```\n\n此外，还有几个这个方法的衍生方法：   \n\n### - ignore: (id)\n忽略给定的值，注意，这里忽略的既可以是地址相同的对象，也可以是`- isEqual:`结果相同的值，也就是说自己写的Model对象可以通过重写`- isEqual:`方法来使`- ignore:`生效。常用的值的判断没有问题，如下：      \n\n\n```\n[[self.inputTextField.rac_textSignal ignore:@\"sunny\"] subscribeNext:^(NSString *value) {\n    NSLog(@\"`sunny` could never appear : %@\", value);\n}];\n```\n\n### - ignoreValues\n这个比较极端，忽略所有值，只关心Signal结束，也就是只取`Comletion`和`Error`两个消息，中间所有值都丢弃。   \n注意，这个操作应该出现在Signal有终止条件的的情况下，如`rac_textSignal`这样除`dealloc`外没有终止条件的Signal上就不太可能用到。   \n\n\n### - distinctUntilChanged\n也是一个**相当常用**的Filter（但它不是- filter:的衍生方法），它将这一次的值与上一次做比较，当相同时（也包括`- isEqual:`）被忽略掉。   \n比如UI上一个Label绑定了一个值，根据值更新显示的内容:\n\n```\nRAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];\nself.user.username = @\"sunnyxx\"; // 1st\nself.user.username = @\"sunnyxx\"; // 2nd\nself.user.username = @\"sunnyxx\"; // 3rd\n```\n\n如果不增加`distinctUntilChanged`的话对于连续的相同的输入值就会有不必要的处理，这个栗子只是简单的UI刷新，但遇到如写数据库，发网络请求的情况时，代价就不能购忽略了。  \n\n所以，对于相同值可以忽略的情况，果断加上它吧。   \n\n\n\n##起止点过滤类型\n除了被动的当next值来的时候做判断，也可以主动的提前选择开始和结束条件，分为两种类型：\n`take型（取）`和`skip型(跳)`\n\n###- take: (NSUInteger)\n从开始一共取N次的next值，不包括`Competion`和`Error`，如：   \n\n```\n[[[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    [subscriber sendNext:@\"1\"];\n    [subscriber sendNext:@\"2\"];\n    [subscriber sendNext:@\"3\"];\n    [subscriber sendCompleted];\n    return nil;\n}] take:2] subscribeNext:^(id x) {\n    NSLog(@\"only 1 and 2 will be print: %@\", x);\n}];\n```\n\n###- takeLast: (NSUInteger)\n取最后N次的next值，注意，由于一开始不能知道这个Signal将有多少个next值，所以RAC实现它的方法是将所有next值都存起来，然后**原Signal完成时**再将后N个**依次**发送给接收者，但Error发生时依然是立刻发送的。 \n###- takeUntil:(RACSignal *)\n当给定的signal完成前一直取值。最简单的栗子就是`UITextField`的`rac_textSignal`的实现（删减版本）: \n\n```\n- (RACSignal *)rac_textSignal {\n\t@weakify(self);\n\treturn [[[[[RACSignal\n\t\tconcat:[self rac_signalForControlEvents:UIControlEventEditingChanged]]\n\t\tmap:^(UITextField *x) {\n\t\t\treturn x.text;\n\t\t}]\n\t\ttakeUntil:self.rac_willDeallocSignal] // bingo!\n}\n```  \n也就是这个Signal一直到textField执行`dealloc`时才停止\n   \n###- takeUntilBlock:(BOOL (^)(id x))  \n对于每个next值，运行block，当block返回YES时停止取值，如： \n  \n```\n[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) {\n    return [value isEqualToString:@\"stop\"];\n}] subscribeNext:^(NSString *value) {\n    NSLog(@\"current value is not `stop`: %@\", value);\n}];\n```\n\n###- takeWhileBlock:(BOOL (^)(id x))\n上面的反向逻辑，对于每个next值，block返回\tYES时才取值\n\n\n###- skip:(NSUInteger)   \n从开始跳过N次的next值，简单的栗子：  \n\n```\n[[[RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n    [subscriber sendNext:@\"1\"];\n    [subscriber sendNext:@\"2\"];\n    [subscriber sendNext:@\"3\"];\n    [subscriber sendCompleted];\n    return nil;\n}] skip:1] subscribeNext:^(id x) {\n    NSLog(@\"only 2 and 3 will be print: %@\", x);\n}];\n```\n###- skipUntilBlock:(BOOL (^)(id x))  \n和`- takeUntilBlock:`同理，一直跳，直到block为YES\n###- skipWhileBlock:(BOOL (^)(id x)) \n和`- takeWhileBlock:`同理，一直跳，直到block为NO\n\n-----\n\n#总结\n本章介绍了RAC中Filter类型的Operation，总结一下：\n\n- 适用场景：需要一个next值集合的`子集`时\n- Filter类型：值过滤型和起止点过滤型\n- 值过滤型常用方法： `-filter:`，`-ignore:`，`-distinctUnitlChanged`\n- 起止点过滤型常用方法：`take`系列和`skip`系列\n\n\n\n#References\n\nhttps://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md#filtering\n\n---\n原创文章，转载请注明源地址，[blog.sunnyxx.com](blog.sunnyxx.com)","mtime":1398131188000,"source":"_posts/rac_4_filters.md","_id":"9uq86nvpgle077l9"},"a7eobzc5rfmwk4yq":{"content":"title: Xcode plugins memo\ndate: 2014-03-14 23:27:13\ntags: xcode\n---\n\n##FuzzyAutocomplete\ngithub：https://github.com/chendo/FuzzyAutocompletePlugin\n![FuzzyAutocomplete](https://raw.github.com/chendo/FuzzyAutocompletePlugin/master/demo.gif)\n\n一个支持**模糊匹配**的代码提示优化插件，支持了xcode5.1\n注意：使用的时候有个输入字母字数小于3就输入不了的bug。  \n效率必备。\n\n##KSImageNamed\ngithub: https://github.com/ksuther/KSImageNamed-Xcode\n![KSImageNamed](https://raw.github.com/ksuther/KSImageNamed-Xcode/master/screenshot.gif)\n输入`imageNamed:`之后快速预览选择图片  \n注意：项目中图片文件数量很多的时候，安装这个插件导致xcode运行明显缓慢，不知道现在版本是否已经修改了这个bug  \n手写UI的尤其适用，我等sb党用的少点。\n\n##HOStringSense\ngithub: https://github.com/holtwick/HOStringSense-for-Xcode\n![HOStringSense](https://github.com/holtwick/HOStringSense-for-Xcode/raw/master/StringDemoAnimation.gif)\n帮助快速输入字符串，尤其是长段复杂的字符串。\n\n> to be continue...\n","mtime":1395386463000,"source":"_posts/xcode_plugins.md","_id":"a7eobzc5rfmwk4yq"}}}