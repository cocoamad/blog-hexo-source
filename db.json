{"Asset":{"hq4h48huq61uhikj":{"_id":"hq4h48huq61uhikj","source":"source/CNAME","mtime":1393488428000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/source/CNAME","path":"CNAME"},"x3ytu90nuxs8rk9r":{"_id":"x3ytu90nuxs8rk9r","source":"source/favicon.ico","mtime":1394012192000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/source/favicon.ico","path":"favicon.ico"},"g929qm0rwrfrukpm":{"_id":"g929qm0rwrfrukpm","source":"themes/present/source/js/script.js","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/js/script.js","path":"js/script.js"},"y7b6a7191rsgj0ti":{"_id":"y7b6a7191rsgj0ti","source":"themes/present/source/css/style.styl","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/style.styl","path":"css/style.styl"},"h6igjesecgepglbe":{"_id":"h6igjesecgepglbe","source":"themes/present/source/css/fonts/FontAwesome.otf","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf"},"5ftgcvtp0udnvz7b":{"_id":"5ftgcvtp0udnvz7b","source":"themes/present/source/css/fonts/fontawesome-webfont.eot","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot"},"p9xja85kslyi6mes":{"_id":"p9xja85kslyi6mes","source":"themes/present/source/css/fonts/fontawesome-webfont.svg","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg"},"3tq64uzmrebpp1s7":{"_id":"3tq64uzmrebpp1s7","source":"themes/present/source/css/fonts/fontawesome-webfont.ttf","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf"},"hx7x4lwx9xreve9v":{"_id":"hx7x4lwx9xreve9v","source":"themes/present/source/css/fonts/fontawesome-webfont.woff","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff"},"xxvp7e8xfuo2dyvw":{"_id":"xxvp7e8xfuo2dyvw","source":"themes/present/source/css/images/banner.png","mtime":1394176314000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/css/images/banner.png","path":"css/images/banner.png"},"vmp4jbh7nimo3ddw":{"_id":"vmp4jbh7nimo3ddw","source":"themes/present/source/fancybox/blank.gif","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/blank.gif","path":"fancybox/blank.gif"},"a0n8lzliliu4gl5z":{"_id":"a0n8lzliliu4gl5z","source":"themes/present/source/fancybox/fancybox_loading.gif","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif"},"jd8k1vhg26oqmflm":{"_id":"jd8k1vhg26oqmflm","source":"themes/present/source/fancybox/fancybox_loading@2x.gif","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif"},"g4jc3yn6tq967iam":{"_id":"g4jc3yn6tq967iam","source":"themes/present/source/fancybox/fancybox_overlay.png","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png"},"bjo8h3ly1u6ybl8d":{"_id":"bjo8h3ly1u6ybl8d","source":"themes/present/source/fancybox/fancybox_sprite.png","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png"},"ple8w8olcyjchns5":{"_id":"ple8w8olcyjchns5","source":"themes/present/source/fancybox/fancybox_sprite@2x.png","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png"},"plbyt4t19rmgv9jm":{"_id":"plbyt4t19rmgv9jm","source":"themes/present/source/fancybox/jquery.fancybox.css","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css"},"imqeiywxqc4ifn2m":{"_id":"imqeiywxqc4ifn2m","source":"themes/present/source/fancybox/jquery.fancybox.js","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js"},"aibrbzghlei0774s":{"_id":"aibrbzghlei0774s","source":"themes/present/source/fancybox/jquery.fancybox.pack.js","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js"},"b2oilt5spngcxiwb":{"_id":"b2oilt5spngcxiwb","source":"themes/present/source/fancybox/helpers/fancybox_buttons.png","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png"},"xbmsx6bw8767psss":{"_id":"xbmsx6bw8767psss","source":"themes/present/source/fancybox/helpers/jquery.fancybox-buttons.css","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css"},"5zncyok9a54wsnhm":{"_id":"5zncyok9a54wsnhm","source":"themes/present/source/fancybox/helpers/jquery.fancybox-buttons.js","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js"},"rcbwcdevwkhjd467":{"_id":"rcbwcdevwkhjd467","source":"themes/present/source/fancybox/helpers/jquery.fancybox-media.js","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js"},"21lpt6mz8h2bmehj":{"_id":"21lpt6mz8h2bmehj","source":"themes/present/source/fancybox/helpers/jquery.fancybox-thumbs.css","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css"},"znilaglpe3yocxye":{"_id":"znilaglpe3yocxye","source":"themes/present/source/fancybox/helpers/jquery.fancybox-thumbs.js","mtime":1394176893000,"modified":false,"full_source":"/Users/yuan.sun/git/blog-hexo-source/themes/present/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js"}},"Cache":{"6iozlkqkvnoncz65":{"_id":"6iozlkqkvnoncz65","content":"title: hexo的私人订制\ndate: 2014-03-07 16:26:34\ntags: hexo\n---\n\n#准备工作\n##Fork it!\n从0开始多费劲，先从hexo的主题中选一个看的过去的，从上面加工。\n这次选的是hexo的默认主题`Landscape`，觉得一个大banner挺好看而已。\n主题在github上，https://github.com/hexojs/hexo-theme-landscape  \n废话不说，先fork一份，虽然不会再merge回去了。\nfork完去setting页面改个名字，就叫它`present`了，因为当时看到群里正说`presentViewController`的事- -\n![][1]\n * hexo工程的`themes/`目录默认是在`.gitignore`里的，意思是主题和内容是应该分开的\ntheme作为主项目的`submodule`，所以主题更改时也应该单独提交了\n\n##Clone it！\n把刚fork的名为`present`的theme安装到hexo目录：\n``` sh\n$ git clone https://github.com/sunnyxx/present themes/present\n```\n去`/_config.yml`中找到并设置：\n```\n# Extensions\n## Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n## Themes: https://github.com/tommy351/hexo/wiki/Themes\ntheme: present // 修改这儿\n```\n运行下`hexo server`就能立刻看到效果了\n\n#开始定制theme\n先得看看hexo theme里面的结构：\n\n - _config.yml - 主题总体配置\n - /layout/*.ejs - 网页布局\n - /source/css/*.styl - 网页样式\n\n##定制banner\n![banner][2]\n默认的banner图是个地球星空图，先从它下手，这张图位于`/themes/present/source/css/images/banner.jpg`\n这图分辨率有`1920x1200`之大，显示的部分很少，搞一张喜欢的banner图，PS成大概的尺寸（高度还就得设的很大才行，虽然只显示一小部分，否则会出现显示不出来图片的状况），我这儿PS过的是一张png，名为`banner.png`，文件名修改需找找到位于`/themes/present/source/css/_variables.styl`中，修改为`banner.png`：\n```\n// Header\nlogo-size = 40px\nsubtitle-size = 16px\nbanner-height = 404px // 看看多高合适\nbanner-url = \"images/banner.png\" // 修改这里\n```\n然后就变成这鸟样了：\n![专业多了][3]\n这个标题横在这儿太恶心了，我的banner里面已经有标题了，这就是需要修改布局了，header的布局在`/themes/present/layout/_partial/header.ejs`，打开修改：\n```\n// 把这一段都注释掉好了：\n<div id=\"header-title\" class=\"inner\">\n    <h1 id=\"logo-wrap\">\n        <a href=\"<%- config.root %>\" id=\"logo\"><%= config.title %></a>\n    </h1>\n    <% if (theme.subtitle){ %>\n        <h2 id=\"subtitle-wrap\">\n          <a href=\"<%- config.root %>\" id=\"subtitle\"><%= theme.subtitle %></a>\n        </h2>\n    <% } %>\n</div>\n```\n然后世界变清净了。\n![丑][4]\n默认主题里面banner上下都有个渐变，换了图之后就尤其丑，干掉之。\n这个是样式的修改，所以肯定在`present/source/css/_partial`里面了，再看这位置明显是header嘛，所以`header.styl`就是你了：\n```\n#header\n  height: banner-height\n  position: relative\n  border-bottom: 1px solid color-border\n  &:before, &:after\n    content: \"\"\n    position: absolute\n    left: 0\n    right: 0\n    height: 40px\n  &:before\n    top: 0\n    background: linear-gradient(rgba(0, 0, 0, 0.2), transparent) // 找到你了，注释掉！\n  &:after\n    bottom: 0\n    background: linear-gradient(transparent, rgba(0, 0, 0, 0.2)) // 也找到你了，注释掉！\n```\n瞬间清爽很多，但又发现去掉之后字看不清了：\n![看不清！][5]\n还是在这个文件：\n\n```\n$nav-link\n  float: left\n  color: #000 // 改个深色\n  opacity: 1.0 // 别半透明的\n  text-decoration: none\n  /*text-shadow: 0 1px rgba(0, 0, 0, 0.2)*/ // 改个阴影\n  transition: opacity 0.2s\n  display: block\n  padding: 20px 15px\n  &:hover\n    opacity: 1\n```\nmuch better\n![better][6]\n\n##定制文章样式\n\n列几个常用的：\n\n在`/themes/present/source/css/_variables.styl`中：\n\n####调整主区域布局（很值得修改）\n默认的主题的主区域太窄了，没几个字就得换行，下面的`main-column`控制主区域宽，`sidebar-column`控制sidebar宽，这两个值加一起凑成全部宽度，会居中对齐。\n```\n// Layout\nblock-margin = 20px\narticle-padding = 20px // 文章内缩进\nmobile-nav-width = 280px\nmain-column = 12 // 主文章区域的宽度\nsidebar-column = 3 // 侧边栏区域的宽度\n```\n####修改代码字体\n\n```\nfont-mono = \"Source Code Pro\", Menlo/*Menlo必须提前面啊*/, Monaco, Consolas, Consolas, monospace\n```\n####修改正文字体和行高\n```\nfont-size = 15px // Menlo字体我看15px的很清楚\nline-height = 1.6em\nline-height-title = 1.3em\n```\n\n\n-----\n位于`/themes/present/source/css/_partial/article.styl`的样式文件负责文章里面的样式\n####修改图片格式\n```\n  img, video\n    max-width: 100%\n    height: auto\n    display: block\n    margin: 10 10 10 10 // 默认丫居中的，改成左对齐好了\n```\n####修改blockquote样式\n```\n  blockquote\n    font-family: font-serif\n    font-size: 2.0em // 搞大点\n    margin: line-height 20px\n    text-align: left // 必须应该左对齐啊\n```\n\n-----\n位于`/themes/present/source/css/_extend.styl`的样式文件定义了基本样式\n####修改标题样式\n```\n  h1\n    font-size: 2em\n  h2\n    font-size: 1.5em\n  h3\n    font-size: 1.3em\n  h4\n    font-size: 1.2em\n  h5\n    font-size: 1em\n  h6\n    font-size: 1em\n    color: color-grey\n```\n\n####修改文章背景\n```\n$block\n  background: #fbfbfb // 白里透着灰\n  /*box-shadow: 1px 2px 3px #eee*/ // 扁平化咋能要阴影\n  border: 1.5px solid #ccc // 边框\n  border-radius: 10px // 圆角矩形走起\n```\n\n#开始定制widget\n// TODO:\n##添加多说评论\n// TODO:\n##添加友情链接\n// TODO:\n\n  [1]: http://ww3.sinaimg.cn/large/51530583gw1ee7835uauoj20j804mwen.jpg\n  [2]: http://ww4.sinaimg.cn/large/51530583gw1ee78mkdkspj20jp06bq3h.jpg\n  [3]: http://ww2.sinaimg.cn/large/51530583gw1ee790pxkk9j20fv085t9c.jpg\n  [4]: http://ww3.sinaimg.cn/large/51530583gw1ee79b2xop4j201u0bt0sm.jpg\n  [5]: http://ww4.sinaimg.cn/large/51530583gw1ee79ex02pgj206901u0qo.jpg\n  [6]: http://ww3.sinaimg.cn/large/51530583tw1ee79mmlwkaj205401iwe9.jpg","mtime":1394184669000,"source":"_posts/hexo_customize.md"},"n5ehkypvy5dlgztv":{"_id":"n5ehkypvy5dlgztv","content":"title: ios6级考试-基础\ndate: 2014-03-06 23:10:58\ntags:\n---\n\n```\n...\n[request startAsync];\nsleep(100);\n[request setCompetionBlock:^{\n\tNSLog(@\"Can I be print?\");\n}];\n...\n```\n","mtime":1394156244000,"source":"_posts/ios_exam_0.md"},"pgl9poffegg4h1n5":{"_id":"pgl9poffegg4h1n5","content":"title: 使用hexo搭建blog边做边记\ndate: 2014-02-27 14:56:47\ntags: hexo\n---\n\n#Install\n**安装nvm（Node Version Manager）**，Terminal中运行\n\n    $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n会提示：\n\n    => Close and reopen your terminal to start using NVM\n退出Terminal重启后nvm命令才能生效。  使用nvm安装node.js：\n<!--more--> \n    $ nvm install 0.10\n下完后安装hexo，这一步时间比较长：\n\n    $ npm install -g hexo\n\n然后找个文件初始化blog：\n\n    $ cd ~/git/blog  \n    $ hexo init .\n    $ ls\n生成出的目录结构：\n\n    .\n    ├── _config.yml\n    ├── package.json\n    ├── scaffolds\n    ├── scripts\n    ├── source\n    |   ├── _drafts\n    |   └── _posts\n    └── themes\n\n新建一篇文章：\n\n    $ hexo new mac下使用hexo搭建blog\n$ open source/_posts/mac下使用hexo搭建blog.md \n编辑md后生成html：\n\n    $ hexo generate\n本地预览：\n\n    $ hexo server\n    => [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.\nTheme，去官方提供的[主题列表][1]中选个现成的，按照里面的方法pull下来，如light主题\n\n\n    $ git clone git://github.com/tommy351/hexo-theme-light.git themes/light\n    \n_config.yml配置文件中设置：\n\n    theme: light\n重新generate和server预览，就看到变化了。\n\n##deploy\n\ngithub上建个respository，设置里设一下\n在`_config.yml`中：\n``` yml\ndeploy:\ntype: github\nrepository: https://github.com/sunnyxx/blog-hexo.git\n```\n然后执行：\n\n    $ hexo deploy\n就行了，github会多一个branch，比octopress简单\n\n##绑定域名\n去万网买了这个域名`sunnyxx.com`，以`blog.sunnyxx.com`作为博客的域名，\n看万网是阿里的才从那儿买的，后来发现`DNSPod`貌似比较好，万网的后台做的那叫一个*，但愿解析速度上别再不行就行。\n托管在github上，首先建一个CNAME文件，里面写`最终指向`的域名：\n``` bash\n$ blog.sunnyxx.com > public/CNAME\n```\n然后去域名后台配置下，由于github表示说我托管的页面的域名是：`sunnyxx.github.io`\n所以建一个CNAME记录，将`blog.sunnyxx.com`解析到`sunnyxx.github.io`\nDNS域名解析最常用的是**A记录**和**CNAME记录**，A记录把域名解析到服务器IP，CNAME相当于把一个域名指向另一个域名，因此我这个用的是CNAME，要是托管的服务器也是自己搭的那就用A记录了。\n完事之后得等一段时间（DNSPod说几秒内就同步完，要是这样真心是它好）\n使用下面的命令测一下域名的解析\n``` bash\n$ dig blog.sunnyxx.com +nostats +nocomments +nocmd\n\n=> output:\n;; global options: +cmd\n;blog.sunnyxx.com.      IN  A\nblog.sunnyxx.com.   1778    IN  CNAME   sunnyxx.github.io.\nsunnyxx.github.io.  1778    IN  CNAME   github.map.fastly.net.\ngithub.map.fastly.net.  30  IN  A   103.245.222.133\n```\n这说明是成功了，发现解析过程是`blog.sunnyxx.com`->`sunnyxx.github.io`->`github.map.fastly.net`->`103.245.222.133` 最终指向了github的web server\n由于国内GreatWall，解析速度明显不稳定，有时候都连不上，以后再看怎么办吧\n\n##添加sitemap\n同样的，我们使用hexo提供的插件，方法与添加RSS类似。\n安装sitemap到本地：\n```\nnpm install hexo-generator-sitemap\n```\n开启sitemap功能：编辑hexo/_config.yml，添加如下代码：\n```\nplugins:\n- hexo-generator-sitemap\n```\n访问zipperary/sitemap.xml即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。\n\n\n\n##文章中插入图片\n\n原来用octopress写的时候在目录下面建个`images`目录来保存图片，引用时使用了相对路径就行了，但这是让我最蛋疼的事，想发个图片还得命个名，然后`mv`过去，再引进来，特别墨迹。hexo中当然也可以用这种方法，但是发现使用个`图床`来搞定图片真是一劳永逸了。\n\n\n**微博图床**，地址http://weibotuchuang.sinaapp.com/，我是chrome用户，所以下了个他的插件，装完了点开发现直接把图片拖进去就行了：\n![enter image description here][3]\n生成的地址直接用就行了\n有时候需要使用QQ截屏，只要随便截到某个人的聊天窗口里面，不用发送，然后直接拖拽到这个小窗口里面就OK了。\n> Life saver.\n\nPS：gif也没问题\n![1231231][2]\n##StackEdit - 超赞的Markdown在线编辑器  \n\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"500px\" />\n\n界面干净，所见即所得，支持同步到`Dropbox`和`github`，这个特别好，比如在公司写了点东西就可以一键同步，保留犯罪现场，回来之后继续写剩下的。\n\n遇到的问题\n-----\n第二次用的时候发现安装的hexo命令找不到了，重新use一下：\n```\n$ nvm use 0.10\n```\n\n**使用StackEdit时改变图片大小**\n\n```\n<img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px align=\"center\" />\n```\n效果：\n  <img src=\"http://ww2.sinaimg.cn/large/51530583gw1ee1a7efwa0j20hk03kwen.jpg\" width=\"200px\" />\n\n##添加友情链接\n\n`themes/xxxxxx/layout/_widget/blogroll.ejs`\n```\n<div class=\"widget tag\">\n<h3 class=\"title\">友情链接</h3>\n<ul class=\"entry\">\n<li><a href=\"http://zhouxl.github.io\" title=\"小六\">小六的博客</a></li>\n</ul>\n</div>\n```\n\n  [1]: https://github.com/tommy351/hexo/wiki/Themes\n  [2]: http://ww2.sinaimg.cn/large/51530583gw1ee17y3p11zg207804lnhh.gif\n  [3]: http://ww2.sinaimg.cn/large/51530583gw1ee18d6ak6yj208c08ydg6.jpg\n  [4]: https://stackedit.io/res-min/img/logo-promo-128.png ","mtime":1394173558000,"source":"_posts/mac下使用hexo搭建blog.md"},"kh88bonk65bs4p7f":{"_id":"kh88bonk65bs4p7f","content":"layout: objc\ntitle: objc category的秘密\ndate: 2014-03-05 17:37:19\ntags:\n---\n\n##category的真面目\nobjc所有类和对象都是c结构体，category当然也一样，下面是`runtime`中category的结构：\n``` objc\nstruct _category_t {\n\tconst char *name; // 1\n\tstruct _class_t *cls; // 2\n\tconst struct _method_list_t *instance_methods; // 3\n\tconst struct _method_list_t *class_methods; // 4\n\tconst struct _protocol_list_t *protocols; // 5\n\tconst struct _prop_list_t *properties; // 6\n};\n```\n<!--more--> \n 1. `name`注意，并不是category小括号里写的名字，而是类的名字\n 2. `cls`要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据`name`对应到类对象\n 3. `instance_methods`这个category所有的`-`方法\n 4. `class_methods`这个category所有的`+`方法\n 5. `protocols`这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的\n 6. `properties`这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会`@synthesize`实例变量，一般有需求添加实例变量属性时会采用`objc_setAssociatedObject`和`objc_getAssociatedObject`方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。\n\n###编译器，你对category干了什么？\n\n举个栗子看，定义下面一个类和它的category，实现忽略，保存为`sark.h`和`sark.m`\n``` objc\n@interface Sark : NSObject\n- (void)speak;\n@end\n\n@interface Sark (GayExtention)\n- (void)burst;\n@end\n```\n请出clang的重写命令：\n``` bash\n$ clang -rewrite-objc sark.m\n```\n同级目录下会生成`sark.cpp`，这就是`objc`代码重写成`c++`(基本就是c)的实现。\n打开生成的文件，发现茫茫多，排除include进来的header，自己的代码都在文件尾部了，看看上面的category被编译器搞成什么样子了：\n``` c\nstatic struct _category_t _OBJC_$_CATEGORY_Sark_$_GayExtention __attribute__ ((used, section (\"__DATA,__objc_const\"))) = \n{\n\t\"Sark\",\n\t0, // &OBJC_CLASS_$_Sark,\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention,\n\t0,\n\t0,\n\t0,\n};\n```\n先注意这个category的名字`_OBJC_$_CATEGORY_Sark_$_GayExtention`，这是一个按规则生成的符号了，中间的`Sark`是类名，后面的`GayExtention`是类别的名字，这也就是为什么**同一个类的category名不能冲突**了  \n\n对应看上面`_category_t`的定义，因为category里面只添加了一个`- burst`方法，所以只有实例方法那一项被填充了值`_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention`\n\n其中`_I_Sark_GayExtention_burst`符号就代表了category里面的`- burst`方法，同样遵循了一定的命名规范，里面的`I`表示实例方法\n\n最后，这个类的category们生成了一个数组，存在了`__DATA`段下的`__objc_catlist`section里\n``` c\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n\t&_OBJC_$_CATEGORY_Sark_$_GayExtention,\n};\n```\n至此编译器的任务完成了。\n\n###runtime，我的category哪儿去了？\n\n我们知道，category动态扩展了原来类的方法，在调用者看来好像原来类本来就有这些方法似的，有两个事实：\n\n 1. 不论有没有import category 的`.h`，都可以成功调用category的方法，都影响不到category的加载流程，import只是帮助了编译检查和链接过程\n 2. runtime加载完成后，category的**原始信息**在**类结构里**将不会存在\n\n\n这需要探究下**runtime对category的加载过程**，这里就简单说一下\n\n 1. objc runtime的加载入口是一个叫`_objc_init`的方法，在library加载前由libSystem dyld调用，进行初始化操作\n 2. 调用`map_images`方法将文件中的`image`map到内存\n 3. 调用`_read_images`方法初始化map后的`image`，这里面干了很多的事情，像load所有的类、协议和**category**，著名的`+ load`方法就是这一步调用的\n 4. 仔细看category的初始化，循环调用了`_getObjc2CategoryList`方法，这个方法拿出来看看：\n 5. ... \n\n\n``` objc\n#define GETSECT(name, type, sectname)                                   \\\n    type *name(const header_info *hi, size_t *outCount)  \\\n    {                                                                   \\\n        unsigned long byteCount = 0;                                    \\\n        type *data = (type *)                                           \\\n            getsectiondata(hi->mhdr, SEG_DATA, sectname, &byteCount);   \\\n        *outCount = byteCount / sizeof(type);                           \\\n        return data;                                                    \\\n    }\n    \n// ... //\n\nGETSECT(_getObjc2CategoryList, category_t *, \"__objc_catlist\");\n```\n眼熟的`__objc_catlist`，就是上面category存放的数据段了，可以串连起来了\n\n在调用完`_getObjc2CategoryList`后，runtime终于开始了**category的处理**，简化的代码如下\n``` objc\n// Process this category. \n// First, register the category with its target class. \n// Then, rebuild the class's method lists (etc) if \n// the class is realized. \nBOOL classExists = NO;\nif (cat->instanceMethods ||  cat->protocols  ||  cat->instanceProperties) \n{\n    addUnattachedCategoryForClass(cat, cls, hi);\n    if (isRealized(cls)) {\n        remethodizeClass(cls);\n        classExists = YES;\n    }\n}\n\nif (cat->classMethods  ||  cat->protocols ) \n{\n    addUnattachedCategoryForClass(cat, cls->isa, hi);\n    if (isRealized(cls->isa)) {\n        remethodizeClass(cls->isa);\n    }\n}\n```\n首先分成两拨，一拨是实例对象相关的调用`addUnattachedCategoryForClass`，一拨是类对象相关的调用`addUnattachedCategoryForClass`，然后会调到`attachCategoryMethods`方法，这个方法把一个类所有的category_list的所有方法取出来组成一个`method_list_t **`，注意，这里是`倒序`添加的，也就是说，新生成的category的方法会先于旧的category的方法插入\n```\nstatic void \nattachCategoryMethods(class_t *cls, category_list *cats, \n                      BOOL *inoutVtablesAffected)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    BOOL isMeta = isMetaClass(cls);\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);\n\n    _free_internal(mlists);\n\n}\n```\n生成了所有method的list之后，调用`attachMethodLists`将所有方法`前序`添加进类的方法的数组中，也就是说，如果原来类的方法是a,b,c，类别的方法是1,2,3，那么插入之后的方法将会是1,2,3,a,b,c，也就是说，原来类的方法被category的方法`覆盖`了，但被覆盖的方法确实还在那里。","mtime":1394156244000,"source":"_posts/objc_category_secret.md"},"64aeweg40rm0ndk1":{"_id":"64aeweg40rm0ndk1","content":"title: Reactive Cocoa Tutorial [0] = \"Overview\";\ndate: 2014-03-06 21:58:30\ntags: Reactive Cocoa Tutorial\n---\n关于这系列（如果真能写下去的话）：说是教程有点狂，边学边总结，更像个笔记吧，等完全用透之后再写就会忘了一开始学习过程中遇到的问题了，Reactive Cocoa（RAC）现在资料真心少，中文英文加起来没几篇，还都是转来转去的。这是个好东西，相信以后用的人会变多，转了请留该文原地址哦~  by sunny\n<!--more-->\n> PS:\n> 这篇文章原来发布在blogcn上，http://www.cnblogs.com/sunnyxx，\n> 现在建了自己的blog后会在这上面继续写了。\n\n------\n\n###废话少说 --> **RAC**\n\n　　是什么？怎么来的？干啥用的？ 怎么用的？ 可以观摩无网不剩的blog RAC介绍1和2，在此不啰唆了，简而言之，就是一个函数响应式编程思想在Cocoa下的实现。\n\n###说说在RAC框架下做了一个项目的赶脚吧：\n\n - 挺新鲜挺有意思，开发人员水平很高，框架封装性和实用性一流，看了看人家对宏的使用发现原来用的纯小儿科，对编译器的控制，block的使用也很值得的学习。\n - 编程思想上的一些改变。原创的一个可能也不大恰当的比喻：原来的编程思想像是“走迷宫”，RAC的编程思想是“建迷宫”。意思是，之前的编程思路是命令式，大概都是“程序启动时执行xxxx，在用户点击后的回调函数执行xxx，收到一个Notification后执行xxx”等等，如同走迷宫一样，走出迷宫需要在不同时间段记住不同状态根据不同情况而做出一系列反应，继而走出迷宫；相比下，RAC的思想是建立联系，像钟表中的齿轮组一样，一个扣着一个，从转动发条到指针走动，一个齿轮一个齿轮的传导（Reactive），复杂但完整而自然。如同迷宫的建造者，在设计时早已决定了哪里是通路，哪里是死路或是哪个路口指向了出口，当一个挑战者（Event）走入迷宫时（Signal），他一定会在设置好的迷宫中的某个路线行走（传递），继而走到终点（Completion）或困死在里面（Error）。\n - 写出代码结构明显不一样。由于RAC将Cocoa中KVO，UIKit Event，delegate，selector等都增加了RAC支持，所以都不用去做很多跨函数的事，比如KVO个对象然后在回调里面xxx，从storyboard里面连个UIButton的IBAction出来xxx，或是设个UITextField的delegate出来去取输入的文本xxx。但在RAC下就像上面比喻的建迷宫，把这些大都放在“-viewDidLoad:”就可以了，当然像UITableView的delegate和data source这么大规模的代理模式就还是老老实实写吧。\n简洁。举个栗子：\n\n\n\n\n我就想干这么个事:\n\n> 一个label一个text field，下面输啥上面显示啥\n\n\n\n\n\n　　老写法大概做法是这个vc实现UITextFieldDelegate协议，把这个text field的delegate设到vc上面，然后在要改变text的那个delegate方法里面取当前text field的text值，再赋给label上；\n\n使用RAC的话就一句话（当然得把这俩控件都IBOutlet出来）：\n\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal; \n```\n看着就挺爽。\n\n复杂的栗子先不举了。\n\n　　总之吧，等今后维护RAC的开发者和使用者把更多的Cocoa的东西归入RAC的框架中，这个框架基本上都可以凌驾于Cocoa这个框架了，意思是甚至用不着知道那些delegate啊KVO啊苹果告诉你是咋用的，用RAC封装的就行了。RAC对于值的显示大都是和property“绑定”的关系，像使用storyboard构建页面时，对于有响应的控件基本都得IBOutlet出来作为一个property，而不是像原来一样连个IBAction出来或者连个delegate出来。对于视图层到model层之间的绑定就显得有些生硬了，相当于视图直接耦合了model，于是应运而生M-V-VM结构，说白了就是在View和Model之间增加了一个ViewModel来解耦，这样View里面要做的基本就是绑定VM以及一些纯视图的操作（比如用什么动画效果展示一个数据）；VM里面是和View相关的数据部分的储存和操作，比如说一个UITableView的data source，一个对email输入合法性的验证方法，当然还有的是对真正Model层的调用和结果的刷新，由于View已经和VM绑定，这样VM在刷新的时候只刷新自己的属性就得了。\n\n　　其实重要的还是写代码思维方式的变化，如果全工程都使用RAC来实现，对于同一个业务逻辑终于可以在同一块代码里完成了，将UI事件，逻辑处理，文件或数据库操作，异步网络请求，UI结果显示，这一大套统统用函数式编程的思路嵌套起来，进入页面时搭建好这所有的关系，用户点击后妥妥的等着这一套联系一个个的按期望的逻辑和次序触发，最后显示给用户。感觉就像是搭好了一个精致的游乐场，然后不紧不慢地打开大门：@\"Come on 熊孩子们！\"\n\n \n\nPS：写这个blog的时候用的RAC版本是2.2.3，现在RAC3.0-dev正开发中，还会有很多变化，可能没写完就出新了，需要修改的我会update。","mtime":1394156244000,"source":"_posts/rac_0_overview.md"},"akkiy12jc79c86u9":{"_id":"akkiy12jc79c86u9","content":"title: Reactive Cocoa Tutorial [1] = \"神奇的Macros\";\ndate: 2014-03-06 22:11:04\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 -- by sunnyxx\n\n---\n\n##先说说RAC中必须要知道的宏：\n```\nRAC(TARGET, [KEYPATH, [NIL_VALUE]])\n```\n使用：\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\n\nRAC(self.outputLabel, text, @\"收到nil时就显示我\") = self.inputTextField.rac_textSignal;\n```\n　　这个宏是最常用的，`RAC()`总是出现在等号左边，等号右边是一个`RACSignal`，表示的意义是将一个对象的一个`属性`和一个`signal`绑定，signal每产生一个value（id类型），都会自动执行：\n```\n[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];\n```\n　　数字值会升级为`NSNumber *`，当setValue:forKeyPath时会自动降级成基本类型（int, float ,BOOL等），所以RAC绑定一个基本类型的值是没有问题的\n\n<!--more-->\n \n```\n　　· RACObserve(TARGET, KEYPATH)\n```\n　　作用是观察TARGET的KEYPATH属性，相当于`KVO`，产生一个`RACSignal`\n\n　　最常用的使用，和RAC宏绑定属性：\n```\nRAC(self.outputLabel, text) = RACObserve(self.model, name);\n```\n　　上面的代码将label的输出和model的name属性绑定，实现联动，name但凡有变化都会使得label输出\n\n```\n@weakify(Obj);\n@strongify(Obj);\n```\n　　这对宏在 `RACEXTScope.h` 中定义，RACFramework好像没有默认引入，需要单独import\n\n　　**他们的作用主要是在block内部管理对self的引用**：\n```\n@weakify(self); // 定义了一个__weak的self_weak_变量\n[RACObserve(self, name) subscribeNext:^(NSString *name) {\n    @strongify(self); // 局域定义了一个__strong的self指针指向self_weak\n    self.outputLabel.text = name;\n}];\n```\n　　这个宏为什么这么吊，前面加@，其实就是一个啥都没干的@autoreleasepool {}前面的那个@，为了显眼罢了。\n\n　　**这两个宏一定成对出现，先weak再strong**\n\n \n\n##除了RAC中常用宏的使用，有一些宏的实现方法也很值得观摩。 \n\n \n\n　　举个高级点的栗子：\n\n　　要干的一件事，**计算一个可变参数列表的长度**。\n\n　　第一反应就是用参数列表的api，`va_start` `va_arg` `va_end`遍历一遍计算个和，但仔细想想，对于可变参数这个事，在**编译前**其实就已经确定了，代码里括号里有多少个参数一目了然。\n\n　　RAC中`Racmetamarcos.h`中就有一系列宏来完成这件事，硬是在预处理之后就拿到了可变参数个数：\n```\n#define metamacro_argcount(...) \\\n    metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\n这个宏由几个工具宏一层层展开，现在模拟一下展开过程：\n\n假如我们要计算的如下：\n```\nint count = metamacro_argcount(a, b, c);\n```\n于是乎**第一层**展开后：\n```\nint count = metamacro_at(20, a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\n再看metamacro_at的定义：\n```\n#define metamacro_at(N, ...) metamacro_concat(metamacro_at, N)(__VA_ARGS__)\n// 下面是metamacro_concat做的事（简写一层）\n#define metamacro_concat_(A, B) A ## B\n```\n于是乎**第二层**展开后：\n```\nint count = metamacro_at20(a, b, c, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1);\n```\n再看metamacro_at20这个宏干的事儿：\n```\n#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)\n```\n于是乎**第三层**展开后，相当于截断了前20个参数，留下剩下几个：\n```\nint count = metamacro_head(3, 2, 1);\n```\n这个metamacro_head：\n```\n#define metamacro_head(...) metamacro_head_(__VA_ARGS__, 0)\n#define metamacro_head_(FIRST, ...) FIRST\n```\n　　后面加个0，然后取参数列表第一个，于是乎：\n```\nint count = 3;\n```\n　　**大功告成。**\n\n　　反正我看完之后感觉挺震惊，宏还能这么用，这样带来的好处不止是将计算在预处理时搞定，不拖延到运行时恶心cpu；但更重要的是编译检查。比如某些可变参数的实现要求可以填2个参数，可以填3个参数，其他的都不行，这样，也只有这样的宏的实现，才能在编译前就确定了错误。\n\n##除了上面，还有一个神奇的宏的使用：\n\n　　当使用诸如`RAC(self, outputLabel)`或`RACObserve(self, name)`时，发现写完逗号之后，**输入第二个property的时候会出现完全正确的代码提示**！这相当神奇。\n![自动代码提示][1]\n\n\n探究一下，关键的关键是如下一个宏：\n```\n#define keypath(...) \\\n    metamacro_if_eq(1, metamacro_argcount(__VA_ARGS__))(keypath1(__VA_ARGS__))(keypath2(__VA_ARGS__))\n```\n这个`metamacro_argcount`上面说过，是计算**可变参数**个数，所以`metamacro_if_eq`的作用就是判断参数个数，如果个数是1就执行后面的keypath1，若不是1就执行keypath2。\n\n所以重点说一下keypath2：\n```\n#define keypath2(OBJ, PATH) \\\n    (((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n　　乍一看真挺懵，先化简，由于Objc里面keypath是诸如\"outputLabel.text\"的字符串，所以这个宏的返回值应该是个字符串，可以简化成：\n```\n#define keypath2(OBJ, PATH) (???????, # PATH)\n```\n先不管\"??????\"是啥，这里不得不说C语言中一个不大常见的语法（第一个忽略）：\n```\nint a = 0, b = 0;\na = 1, b = 2;\nint c = (a, b);\n```\n这些都是**逗号表达式**的合理用法，第三个最不常用了，c将被b赋值，而a是一个未使用的值，编译器会给出warning。\n\n去除warning的方法很简单，强转成void就行了：\n```\nint c = ((void)a, b);\n```\n再看上面简化的keypath2宏，返回的就是PATH的字符串字面值了(单#号会将传入值转成字面字符串)\n\n```\n(((void)(NO && ((void)OBJ.PATH, NO)), # PATH))\n```\n对传入的第一个参数OBJ和第二个正要输入的PATH做了`点`操作，这也正是为什么输入第二个参数时编辑器会给出正确的代码提示。强转void就像上面说的去除了warning。\n\n　但至于为什么加入与`NO`做`&&`，我不太能理解，我测试时其实没有时已经完成了功能，可能是作者为了屏蔽某些隐藏的问题吧。\n\n　　这个宏的巧妙的地方就在于使得编译器以为我们要输入“点”出来的属性，保证了输入值的合法性（输了不存在的property直接报错的），同时利用了逗号表达式取逗号最后值的语法返回了正确的keypath。\n\n \n\n##总之\nRAC对宏的使用达到了很高的水平，还有诸如`RACTuplePack`，`RACTupleUnpack`的宏就不细说了，值得研究。\n\n---\nPS：上面介绍的metamacro和@strongify等宏确切来说来自RAC依赖的extobjc，作者是Justin Spahr-Summers，正是RAC作者之一。\n\n\n  [1]: http://images.cnitblog.com/blog/401798/201402/112147518936541.png","mtime":1394156244000,"source":"_posts/rac_1_macros.md"},"ck2jfctuvyhw96o9":{"_id":"ck2jfctuvyhw96o9","content":"title: Reactive Cocoa Tutorial [2] = \"百变RACStream\";\ndate: 2014-03-06 22:34:27\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 -- by sunny\n\n\n##Overview\n\n　　在RAC下开发干的最多的事就是建立RACSignal和subscribe RACSignal了，它是RAC的核心所在。本篇介绍了RAC的运作原理和设计思路，从函数式编程形成的RACStream继而介绍它的子类 - RAC最核心的部分RACSignal。\n\n##函数式编程\n\n　　我们知道Reactive Cocoa是函数式编程(Functional Programing)(FP)思想的实现。FP有一套成熟的理论，这里只讲讲我个人理解吧。\n\n　　我觉得FP就是“**像计算函数表达式一样来解决一个问题**”，举个栗子，中学题：\n\n<!--more-->\n\n```\n已知：f(x) = 2sin(x + π/2)， 求 f(π/2)的值。\n```\n　　其中x是这个函数的输入，f(x)为计算的输出结果，求f(π/2)时给定了x自然能计算出个结果来（说实话我真忘了咋算了）\n\n当然，仔细看这个函数，其实是可以分解成几个小函数的：\n\n```\nf1(x) = x + π/2\nf2(x) = sin(x)\nf3(x) = 2x\n```\n　　而原来的f(x)可以被小函数组合：\n```\nf(x) = f3(f2(f1(x)))\n```\n　　所以不难得出这么个推论：要是我手上有足够的**基本函数**，我就能用上面的组合的方法组合出任意一个**复杂的函数**了。再想想事实上这些年来学数学的过程不就是在一个个积累基本函数的过程嘛，从基本运算，到三角函数，到乘方开方，再到微积分。基本函数越来越多，能解决的数学问题也越来越复杂。\n\n　　再来看一个函数是怎么构成的，FP理论里叫`monads`，十分抽象，没读懂，但能理解出来：一个函数只要有一个对于输入值的运算方法和一个返回值，就够了。也容易理解，给它一个输入，干点事情，给出一个输出，就行了，当然现实情况要复杂得多（比如说输出值本身就是个函数？）有些函数是有输入的条件的，比如原来数学解个函数时候经常跟个作用域或者限制条件，比如`f(x) = 10 / x , (x不为0)`，要是传个0这个函数就认为计算错误。\n\n　　对于像上面栗子的函数，每个函数都能接收上一个函数输出的结果，作为自己的输入，这样才能嵌套生成最终结果，同时，计算的顺序也是一定从里向外，所以换个写法可以写成：\n\n```\nstart ---x--> f1(x) --(temp value1)--> f2(temp value1) --(temp value2)--> f3(temp value2) ---> result\n```\n　　于是乎**嵌套**就被表示成了**序列**，来个高大上的名字怎么样，就叫**流（Stream）**\n\n##RACStream\n\n　　这就是`RACStream`所表示的含义。\n\n　　按照上面说的，其实`RACStream`的名字有点点歧义，对于一个`RACStream`对象，它在意义上等同于上面的f1(x),f2(x),f3(x)，而不是那一大串整体，表示整体的应该是最外层的和f(x)对应的那个对象，叫个RACStreamComponent比较好？理解时候得注意下。\n\n　　所以作为一个基本函数的RACStream应该至少应该有：\n\n 1. 怎么传入值\n 2. 怎么返回值\n 3. 怎么与其他函数组合\n 4. 怎么实现函数的作用域(监测输入值来做处理)\n 5. 这函数叫啥- -\n\n\n得益于在Objc下实现，所以输入输出的“值”都用个`id`类型就行了，遇到多个值的组合就用`RACTurple`（可以把多个值压包和解包，类比WINRAR），1和2解决\n\nRACStream从实例变量来看只有一个`name`，当然它也只应该有个name - -，5解决\n\n　　里面重点问题就是上面的3和4了。由于**函数组合之后仍然是个函数**，所以也很容易理解**两个Stream对象的组合其实就是生成一个新的Stream对**象，它返回了分别由两个子Stream先后运算产生的最终结果\n\n 　　观摩一下RACStream定义的基本方法：\n```\n+ (instancetype)empty;\n+ (instancetype)return:(id)value;\n- (instancetype)bind:(RACStreamBindBlock (^)(void))block; // for 4\n- (instancetype)concat:(RACStream *)stream; // for 3\n- (instancetype)zipWith:(RACStream *)stream; // for 3\n```\n　　RACStream作为一个描述抽象的父类，这几个基本方法并没有实现，是由具体子类来实现，RACStream的两个子类分别是`RACSignal`和`RACSequence`\n\n　　\n\n - `+empty` 是一个不返回值，立刻结束(Completed)的函数，意思是执行它之后除了立刻结束啥都不会发生，可以理解为RAC里面的nil。\n\n\n\n - `+return:` 是一个直接返回给定值，然后立刻结束的函数，比如 f(x) = 213\n\n - `-bind:`是一个非常重要的函数，在Rac Doc中被描述为‘**basic primitives, particularly**’，它是RACStream监测“值”和控制“运行状态”的基本方法，个人认为看注释文档不能理解它是干嘛的，而且bind英语“捆绑，绑定，强迫，约束”这几个意思也感觉对不上，我觉得叫“**绑架**”倒是更贴切一点。在-bind：之后，之前的RACStream就处于被“绑架”的状态，被绑架的RACStream每产生一个值，都要经过“绑架者”来决定：\n\n1. 是否使这个RACStream结束（被绑架者是否还能继续活着）\n\n2. 用什么新的RACStream来替换被绑架的RACStream，传出的结果也成了新RACStream产生的值（绑匪可以选择再抓一个人质放之前那个前面）\n\n 　　举个具体栗子，RACStream的 - take：方法，这个方法使一个RACStream只取前N次的值（有缩减）：\n\n```\n- (instancetype)take:(NSUInteger)count {\n    Class class = self.class;\n    \n    return [[self bind:^{ // self被绑架\n        __block NSUInteger taken = 0;\n\n        return ^ id (id value, BOOL *stop) { // 这个block在被绑架的self每输出一个值得时候触发\n            RACStream *result = class.empty;\n\n            if (taken < count) result = [class return:value]; // 未达到N次时将原值原原本本的传递出去\n            if (++taken >= count) *stop = YES; // 达到第N次值后干掉了被绑架的self\n\n            return result; // 将被绑架的self替换为result\n        };\n    }]];\n}\n```\n 　　`-concat:` 和 `-zipWith:` 就是将两个RACStream连接起来的基本方法了：\n\n`[A concat:B]`中A和B像`皇上`和`太子`的关系，A是皇上，B是太子。皇上健在的时候统治天下发号施令（value），太子就候着，不发号施令（value），当皇上挂了（completed），太子登基当皇上，此时发出的号令（value）是太子的。\n`[C zipWith:D]`可以比喻成一对`平等恩爱的夫妻`，两个人是“绑在一起“的关系来组成一个家庭，决定一件事（value）时必须两个人都提出意见（当且仅当C和D同时都产生了值的时候，一个value才被输出，CD只有其中一个有值时会挂起等待另一个的值，所以输出都是一对值（RACTuple）），当夫妻只要一个人先挂了（completed）这个家庭（组合起来的RACStream）就宣布解散（也就是无法凑成一对输出时就终止）\n##然后呢？\n\n　　除了上面几个基本方法，RACStream还有不少的Operation方法，这些操作方法的实现大都是组合基本的方法来达到特定的目的，虽然是RACStream这个基类实现的，但我觉得还是放在后面介绍RACSignal的时候作为它的使用方法来说比较合适，毕竟绝大多数编程的对象的都是RACStream的两个子类，后面再展开介绍好了。\n\n","mtime":1394156244000,"source":"_posts/rac_2_racstream.md"},"7e28p8k77ylo9tdl":{"_id":"7e28p8k77ylo9tdl","content":"title: Reactive Cocoa Tutorial [3] = \"RACSignal的巧克力工厂“;\ndate: 2014-03-06 22:45:43\ntags: Reactive Cocoa Tutorial\n---\nReactive Cocoa Tutorial 系列，转载请注明该文源地址 http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/  -- by sunnyxx\n\n##Overview\n\n　　上一篇介绍了函数式编程和`RACStream`，使得函数得以串联起来，而它的具体子类，也是RAC编程中最重要的部分，`RACSignal`就是使得算式得以逐步运算并使其有意义的关键所在，本节主要介绍`RACSignal`的机理，具体的使用放到接下来的几节。\n<img src=\"http://pic.jschina.com.cn/0/12/03/96/12039600_602173.jpg\" width=\"400px align=\"center\" />\n\n\n##巧克力工厂的运作模式\n\n　　RACStream实现了一个嵌套函数的结构，如f(x) = f1(f2(f3(x)))，但好像是考试卷子上的一道题，没有人去做它，没得出个结果的话这道题是没有意义的。\n\n<!--more-->\n\n　　OK，现在起将这个事儿都比喻成一个巧克力工厂，f(x)的结果是一块巧克力，f1,f2,f3代表巧克力生产的几个步骤，如果这个工厂不开工，它是没有意义的。\n\n　　再说RACSignal，引用RAC doc的描述：\n　　\n> “A signal, represented by the RACSignal class, is a push-driven\n> stream.”\n\n　　我觉得这个`push-driven`要想解释清楚，需要和RACSequence的`pull-driven`放在一起来看。在巧克力工厂，push-driven是“生产一个吃一个”，而pull-driven是“吃完一个才生产下一个”，对于工厂来说前者是主动模式：生产了巧克力就“push”给各个供销商，后者是被动模式：各个供销商过来“pull”产品时才给你现做巧克力。\n\n###Status\n\n　　所以，对于RACSigna的push-driven的生产模式，首先，当工厂发现没有供销商签合同准备要巧克力的时候，工厂当然没有必要开动生产；只要当有一个以上准备收货的经销商时，工厂才开动生产。这就是RACSignal的休眠（cold）和激活（hot）状态，也就是所谓的冷信号和热信号。一般情况下，一个RACSignal创建之后都处于cold状态，有人去subscribe才被激活。\n\n###Event\n\n　　RACSignal能产生且只能产生三种事件：next、completed，error。\n\n　　next表示这个Signal产生了一个值（成功生产了一块巧克力）\n\n　　completed表示Signal结束，结束信号只标志成功结束，不带值（一个批次的订单完成了）\n\n　　error表示Signal中出现错误，立刻结束（一个机器坏了，生产线立刻停止运转）\n\n　　工厂厂长存了所有供销商的QQ，每当发生上面三件事情的一件时，都用QQ挨个儿发消息告诉他们，于是供销商就能根据生产状态决定要做点什么。当订单完成或者失败后，厂长就会把这个供销商的QQ删了，以后发消息的时候也就没必要通知他了。\n\n###Side Effects\n\n　　RACSignal在被subscribe的时候可能会产生副作用，先举个官方的栗子：\n\n```\n__block int aNumber = 0;\n\n// Signal that will have the side effect of incrementing `aNumber` block \n// variable for each subscription before sending it.\nRACSignal *aSignal = [RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n    aNumber++;\n    [subscriber sendNext:@(aNumber)];\n    [subscriber sendCompleted];\n    return nil;\n}];\n\n// This will print \"subscriber one: 1\"\n[aSignal subscribeNext:^(id x) {\n    NSLog(@\"subscriber one: %@\", x);\n}];\n\n// This will print \"subscriber two: 2\"\n[aSignal subscribeNext:^(id x) {\n    NSLog(@\"subscriber two: %@\", x);\n}];\n```\n　　上面的signal在作用域外部引用了一个int变量，同时在signal的运算过程中作为`next`事件的值返回，这就造成了所谓的`副作用`，因为第二个订阅者的订阅而影响了输出值。\n\n　　我的理解来看，这个事儿做的就不太地道，一个正经的函数式编程中的函数是不应该因为进行了运算而导致后面运算的值不统一的。但对于实际应用的情况来看也到无可厚非，比如用户点击了“登录”按钮，编程时把登录这个业务写为一个login的RACSignal，当然，第一次调用登录和再点一次第二次调用登录的结果肯定不一样了。所以说RAC式编程减少了大部分对临时状态值的定义，但不是全部哦。\n\n　　怎么办呢？我觉得最好的办法就是“约定”，RAC design guide里面介绍了对于一个signal的命名法则：\n\n    Hot signals without side effects 最好使用property，如“textChanged”，不太理解什么情况用到这个，权当做一个静态的属性来看就行。\n    Cold signals without side effects 使用名词类型的方法名，如“-currentText”，“currentModels”，同时表明了返回值是个啥（这个尤其得注意，RACSignal的next值是id类型，所以全得是靠约定才知道具体返回类型）\n    Signals with side effects 这种就是像login一样有副作用的了，推荐使用动词类型的方法名，用对动词基本就能知道是不是有副作用了，比如“-loginSignal”和“-saveToFile”大概就知道前面一个很可能有副作用，后面一个多存几次文件应该没副作用\n\n　　当然，也可以`multicast`一个event，使得某些特殊的情况来共享一个副作用，后面再具体讲，先一个官方的简单的栗子：\n\n```\n// This signal starts a new request on each subscription.\nRACSignal *networkRequest = [RACSignal createSignal:^(id<RACSubscriber> subscriber) {\n    AFHTTPRequestOperation *operation = [client\n        HTTPRequestOperationWithRequest:request\n        success:^(AFHTTPRequestOperation *operation, id response) {\n            [subscriber sendNext:response];\n            [subscriber sendCompleted];\n        }\n        failure:^(AFHTTPRequestOperation *operation, NSError *error) {\n            [subscriber sendError:error];\n        }];\n\n    [client enqueueHTTPRequestOperation:operation];\n    return [RACDisposable disposableWithBlock:^{\n        [operation cancel];\n    }];\n}];\n\n// Starts a single request, no matter how many subscriptions `connection.signal`\n// gets. This is equivalent to the -replay operator, or similar to\n// +startEagerlyWithScheduler:block:.\nRACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];\n[connection connect];\n\n[connection.signal subscribeNext:^(id response) {\n    NSLog(@\"subscriber one: %@\", response);\n}];\n\n[connection.signal subscribeNext:^(id response) {\n    NSLog(@\"subscriber two: %@\", response);\n}];\n```\n　　当地一个订阅者subscribeNext的时候触发了AFNetworkingOperation的创建和执行，开始网络请求，此时又来了个订阅者订阅这个Signal，按理说这个网络请求会被“副作用”，重新发一遍，但做了上面的处理之后，这两个订阅者接收到了同样的一个请求的内容。\n\n###RACScheduler - 生产线\n\n　　RACScheduler是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行，不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了，有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。\n\n　　但值得特殊了解的事实是：\n\n    However, RAC guarantees that no two signal events will ever arrive concurrently. While an event is being processed, no other events will be delivered. The senders of any other events will be forced to wait until the current event has been handled.\n\n　　意思是订阅者执行时的block一定非并发执行，也就是说不会执行到一半被另一个线程进入，也意味着写subscribeXXX block的时候没必要做加锁处理了。\n\n###巧克力的生产工艺\n\n　　RACSignal的厂子建好了，运行的模式也都想好了，剩下的就是巧克力的加工工艺了。\n\n　　有了RACStream的嵌套和组装的基础，RACSignal得以使用组件化的工艺来一步步的加工巧克力，从可可，牛奶，糖等原料，混合到这种巧克力适用的液态巧克力，过滤，提纯，冷却，夹心，压模，再到包装，一个巧克力就产出了。对于不同种类的巧克力，比如酒心巧克力，也不过是把其中的某个组件替换成注入酒心罢了。\n\n　　RACSignal的生产组件，也就是它的各式各样的operation，一个具体业务逻辑的实现，其实也就是选择合适operation按合适的顺序组合起来。\n\n　　还举那个用户在textFiled输入并显示到上面的label中的栗子:\n```\nRAC(self.outputLabel, text) = self.inputTextField.rac_textSignal;\n```\n　　现在需求变成“用户输入3个字母以上才输出到label，当不足3个时显示提示”，OK，好办：\n```\nRAC(self.outputLabel, text) = [[self.inputTextField.rac_textSignal \n    startWith:@\"key is >3\"] /* startWith 一开始返回的初始值 */\n    filter:^BOOL(NSString *value) {\n        return value.length > 3; /* filter使满足条件的值才能传出 */\n}];\n\n```\n　　需求又增加成“**当输入sunny时显示输入正确**”\n\n```\nRAC(self.outputLabel, text) = [[self.inputTextField.rac_textSignal\n    startWith:@\"key is >3\"] // startWith 一开始返回的初始值\n    filter:^BOOL(NSString *value) { // filter使满足条件的值才能传出\n        return value.length > 3; \n    }]\n    map:(NSString *value) {　// map将一个值转化为另一个值输出\n        return [value isEqualToString:@\"sunny\"] ? @\"bingo!\" : value;\n    }];\n\n```\n　　可以看出，基本上一个业务逻辑经过分析后可以拆解成一个个小RACSignal的组合，也就像生产巧克力的一道道工艺了。上面的栗子慢慢感觉就像了一个简陋的输答案的框了。\n\n###然后呢？\n\n　　接下来的几节就具体介绍一下RACSignal的operation方法，RAC提供了很多操作方法，大概总结为几大类：过滤型、XXX型、XXX型，后面再慢慢道来。\n","mtime":1394156244000,"source":"_posts/rac_3_racsignal.md"}}}